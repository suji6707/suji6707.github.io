+++
title = 'Boot'
date = 2025-01-05T00:20:22+09:00
draft = true
+++
# Pointer
variable is named location in memory.
그 메모리에 새로운 값을 할당할 수도 있고,
연산으로 값을 변경할 수도 있다.

포인터는 다른 변수의 주소를 저장하는 변수.

&로 주소를,
*로 값을. 
포멧팅: %v로 포인터 주소의 값 역참조 
fmt.Printf("%v\n", ptr)

message *string
포인터이므로 값에 직접 넣어줘야. 
*message = strings.ReplaceAll(*message, bad, strings.Repeat("*", len(bad)))

Go에서 포인터 쓰는 경우는 대부분 함수에 call by reference로 인자 전달할 때.

🔴 Go에선 struct가 포인터든 실제 값이든 똑같이 `.` 선택자로 접근함.
C에선 포인터면 `->`

포인터는 .나 *로 역참조하기 전 항상 nil인지 먼저 확인해야.


* 포인터 리시버
포인터가 가리키는 값을 변경할 수 있음.
보통 메서드는 리시버를 변경하는 목적이기 때문에
포인터 리시버가 value 리시버보다 훨씬 흔하다.
(애초에 값 리시버는 복사된 값이고 항상 리턴해야만 의미가 있는)

struct(객체)가 포인터가 아니더라도
해당 struct 메서드의 리시버는 포인터를 받아서 쓸 수 있다. 

* 포인터는 shared reference가 필요할 때만 써라
성능 문제가 있다면
1. Stack/Heap
🔺- 로컬변수는 스택이라 포인터보다 값이 더 빠르게 전달된다.
값복사가 있더라도 스택은 빨라서 문제가 안됨. 
2. Copy
- 값복사가 일어나기엔 데이터가 너무 크다면 그때는 포인터를 써서 힙으로 이동시키는게 나을 수 있다.
힙으로 이동시키는 비용보다 그게 더 낫다면.
(🔺포인터를 쓴다는건 malloc으로 힙에 할당하는 것 의미)

=> 🔴 여러곳에서 공통 접근해야하거나 객체가 진짜 클 때만 포인터를 쓴다!

