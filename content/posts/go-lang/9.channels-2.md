+++
title = 'Boot'
date = 2025-01-05T00:20:22+09:00
draft = true
+++
# Channels

### select case
í•˜ë‚˜ì˜ ê³ ë£¨í‹´ì´ ì—¬ëŸ¬ ì±„ë„ì„ ë“£ëŠ” ì¼€ì´ìŠ¤.
ì˜¤ëŠ” ìˆœì„œëŒ€ë¡œ ë°ì´í„°ë¥¼ ì²˜ë¦¬.

default: ë‹¤ë¥¸ ì±„ë„ì¤‘ ì•„ë¬´ë„ ì¤€ë¹„ëœ valueê°€ ì—†ì„ ë•Œ ë¶ˆë¦¼
default caseëŠ” selectê°€ ë¸”ë¡œí‚¹í•˜ëŠ” ê²ƒì„ ë°©ì§€.

## time.Tick
time.Tick(): return channel that sends a value on given interval
time.After(): durationì´ ì§€ë‚œ í›„ value ì „ë‹¬
time.Sleep(): íŠ¹ì • ì‹œê°„ë™ì•ˆ í˜„ì¬ ê³ ë£¨í‹´ì„ ë¸”ë¡œí‚¹.

`time.Tick`ê³¼ `time.After`ëŠ” ì±„ë„ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ë“¤ì…ë‹ˆë‹¤:

1. `time.Tick(duration)`:
- ì£¼ê¸°ì ìœ¼ë¡œ ì‹œê°„ ì‹ í˜¸ë¥¼ ë³´ë‚´ëŠ” ì±„ë„ì„ ë°˜í™˜
- ì§€ì •ëœ ê°„ê²©(`duration`)ë§ˆë‹¤ ì‹ í˜¸ë¥¼ ë³´ëƒ„
- íƒ€ì…: `<-chan time.Time`
```go
ticker := time.Tick(800 * time.Millisecond)
// ë§¤ 0.8ì´ˆë§ˆë‹¤ ì‹ í˜¸ë¥¼ ë³´ëƒ„
```

2. `time.After(duration)`:
- ì§€ì •ëœ ì‹œê°„ì´ ì§€ë‚œ í›„ í•œ ë²ˆë§Œ ì‹ í˜¸ë¥¼ ë³´ë‚´ëŠ” ì±„ë„ì„ ë°˜í™˜
- íƒ€ì…: `<-chan time.Time`
```go
timer := time.After(2800 * time.Millisecond)
// 2.8ì´ˆ í›„ì— í•œ ë²ˆë§Œ ì‹ í˜¸ë¥¼ ë³´ëƒ„
```

ì‹¤ì œ ë™ì‘ ì˜ˆì œ:
```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ticker := time.Tick(1 * time.Second)
    timer := time.After(5 * time.Second)

    for {
        select {
        case <-ticker:
            fmt.Println("Tick at", time.Now())
        case <-timer:
            fmt.Println("Timer finished!")
            return
        }
    }
}
```

ì¶œë ¥:
```
Tick at 2024-01-01 12:00:01
Tick at 2024-01-01 12:00:02
Tick at 2024-01-01 12:00:03
Tick at 2024-01-01 12:00:04
Timer finished!
```

ì´ ì˜ˆì œì—ì„œ:
- `ticker`ëŠ” ë§¤ ì´ˆë§ˆë‹¤ ì‹ í˜¸ë¥¼ ë³´ëƒ„
- `timer`ëŠ” 5ì´ˆ í›„ì— í•œ ë²ˆ ì‹ í˜¸ë¥¼ ë³´ë‚´ê³  í”„ë¡œê·¸ë¨ ì¢…ë£Œ

ì°¸ê³ : ì‹¤ì œ í”„ë¡œë•ì…˜ ì½”ë“œì—ì„œëŠ” `time.Tick` ëŒ€ì‹  `time.NewTicker`ğŸ”´ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. `time.Tick`ì€ ë‚´ë¶€ ë¦¬ì†ŒìŠ¤ë¥¼ ì •ë¦¬í•  ë°©ë²•ì´ ì—†ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

```go
ticker := time.NewTicker(1 * time.Second)
defer ticker.Stop()
// ticker.Cë¡œ ì±„ë„ ì ‘ê·¼
```

---
### Read / Write only
`ch <- chan int`ì™€ `ch <-chan int`ëŠ” ë‹¤ë¥¸ ì˜ë¯¸ë¥¼ ê°€ì§‘ë‹ˆë‹¤.

1. `ch chan int`: ì–‘ë°©í–¥ ì±„ë„ (ì½ê¸°/ì“°ê¸° ëª¨ë‘ ê°€ëŠ¥)
```go
func fibonacci(n int, ch chan int) {
    // chë¡œ ì½ê¸°ì™€ ì“°ê¸° ëª¨ë‘ ê°€ëŠ¥
    ch <- 42    // ì“°ê¸° ê°€ëŠ¥
    x := <-ch   // ì½ê¸° ê°€ëŠ¥
}
```

2. `ch <-chan int`: ì½ê¸° ì „ìš© ì±„ë„
```go
func readCh(ch <-chan int) {
    // chë¡œ ì½ê¸°ë§Œ ê°€ëŠ¥
    x := <-ch   // ì½ê¸° ê°€ëŠ¥
    // ch <- 42 // ì»´íŒŒì¼ ì—ëŸ¬: ì“°ê¸° ë¶ˆê°€ëŠ¥
}
```

3. `ch chan<- int`: ì“°ê¸° ì „ìš© ì±„ë„
```go
func writeCh(ch chan<- int) {
    // chë¡œ ì“°ê¸°ë§Œ ê°€ëŠ¥
    ch <- 42    // ì“°ê¸° ê°€ëŠ¥
    // x := <-ch // ì»´íŒŒì¼ ì—ëŸ¬: ì½ê¸° ë¶ˆê°€ëŠ¥
}
```

ì±„ë„ ë°©í–¥ì„ ì§€ì •í•˜ëŠ” í™”ì‚´í‘œ(`<-`)ì˜ ìœ„ì¹˜ê°€ ì¤‘ìš”í•©ë‹ˆë‹¤:
- `<-chan`: í™”ì‚´í‘œê°€ chan ì•ì— ìˆìœ¼ë©´ ì½ê¸° ì „ìš©
- `chan<-`: í™”ì‚´í‘œê°€ chan ë’¤ì— ìˆìœ¼ë©´ ì“°ê¸° ì „ìš©
- `chan`: í™”ì‚´í‘œê°€ ì—†ìœ¼ë©´ ì–‘ë°©í–¥

---
### db ìŠ¤ëƒ…ìƒ· ë°±ì—… ë¡œê·¸ ì¼€ì´ìŠ¤
```go
func saveBackups(snapshotTicker <-chan time.Time, saveAfter <-chan time.Time, logChan chan<- string) {
    for {
        select {
        case <-snapshotTicker:
            takeSnapshot()
            logChan <- "Taking a backup snapshot..."
        case <-saveAfter:
            saveSnapshot()
            logChan <- "All backups saved!"
            close(logChan)  // ğŸ”´ë¬´í•œë£¨í”„ì˜ ìœ ì¼í•œ ì¢…ë£Œì¡°ê±´.
            return
        default:
            waitForData()
            logChan <- "Nothing to do, waiting..."
            time.Sleep(500 * time.Millisecond)
        }
    }
}
// test.go
snapshotTicker := time.Tick(800 * time.Millisecond) // ğŸ”´duration ì‹œê°„(í•¨ìˆ˜ì¸ì)ë§ˆë‹¤ ì‹ í˜¸ë¥¼ ë³´ë‚´ëŠ” ì±„ë„ì„ ë°˜í™˜í•¨.
saveAfter := time.After(2800 * time.Millisecond)
logChan := make(chan string)
go saveBackups(snapshotTicker, saveAfter, logChan)
```

ì‹¤í–‰ ìˆœì„œ:
1. í”„ë¡œê·¸ë¨ ì‹œì‘
2. 0.5ì´ˆë§ˆë‹¤ "Nothing to do, waiting..." ë¡œê·¸
3. 0.8ì´ˆë§ˆë‹¤ "Taking a backup snapshot..." ë¡œê·¸
4. 2.8ì´ˆ í›„ "All backups saved!" ë¡œê·¸ì™€ í•¨ê»˜ ì¢…ë£Œ

ì´ í…ŒìŠ¤íŠ¸ëŠ” ë°±ì—… ì‹œìŠ¤í…œì´:
- ì£¼ê¸°ì ìœ¼ë¡œ ìƒíƒœë¥¼ ì²´í¬í•˜ê³ 
- ì •í•´ì§„ ê°„ê²©ìœ¼ë¡œ ìŠ¤ëƒ…ìƒ·ì„ ìƒì„±í•˜ë©°
- ì§€ì •ëœ ì‹œê°„ í›„ì— ëª¨ë“  ì‘ì—…ì„ ì™„ë£Œí•˜ëŠ”ì§€ í™•ì¸


---
### ì´ˆê¸°í™”ë˜ì§€ ì•Šì€ ì±„ë„ì€ nil
var c chan string // c is nil
var c = make(chan int) // not nil

nil channel c <- "data" ë¡œ ë³´ë‚´ë ¤í•˜ë©´ senderëŠ” ì˜ì›íˆ blockëœë‹¤.
<-c nil ì±„ë„ì—ì„œ ë°›ìœ¼ë ¤í•˜ë©´ receiverëŠ” ì˜ì›íˆ block.
closed channelì—ì„œ ë°›ìœ¼ë©´ 0. ë³´ë‚´ë ¤í•˜ë©´ íŒ¨ë‹‰.

---
### ping pong ì¼€ì´ìŠ¤
ponger: íì— ì‹ í˜¸
pinger: í•‘ì— ì‹ í˜¸
func()ì˜ ğŸ”´for range pongsëŠ” ì±„ë„ì—ì„œ ê°’ì„ ì½ëŠ” ë°©ë²• ì¤‘ í•˜ë‚˜. 
ë˜ëŠ”
```go
for value := range channel {
    // ì±„ë„ì´ ë‹«í ë•Œê¹Œì§€ ê°’ì„ ê³„ì† ì½ìŒ
}
```

```go
func pingPong(numPings int) {
	pings := make(chan struct{})
	pongs := make(chan struct{})
	go ponger(pings, pongs)
	go pinger(pings, pongs, numPings)
    // ì•„ë˜ê°€ ê³ ë£¨í‹´ìœ¼ë¡œ ì‹¤í–‰ë˜ë©´ ë©”ì¸í•¨ìˆ˜ê°€ ë°”ë¡œ ì¢…ë£Œë˜ì–´ë²„ë¦¼ -> background as a goroutineìœ¼ë¡œ ì‹¤í–‰ë˜ë©´ X
	func() {  
		i := 0
		// ğŸ”´pongs ì±„ë„ì´ ë‹«í ë•Œê¹Œì§€ ë¸”ë¡œí‚¹
		for range pongs {  // ğŸŸ¡ 4.pong ë°›ìŒ
			fmt.Println("got pong", i)
			i++
		}
		fmt.Println("pongs done")
	}()
}

func pinger(pings, pongs chan struct{}, numPings int) {
	for i := 0; i < numPings; i++ {
		pings <- struct{}{}  // ğŸŸ¡ 1.ping ë³´ëƒ„
	}
	close(pings)
}
func ponger(pings, pongs chan struct{}) {
	for range pings { // ğŸŸ¡ 2.ping ë°›ê³ 
        pongs <- struct{}{} // ğŸŸ¡ 3.pong ë³´ëƒ„
    }
    close(pongs)
}

func test(numPings int) {
	fmt.Println("Starting game...")
	pingPong(numPings)
	fmt.Println("===== Game over =====")
}
func main() {
	test(4)
	test(3)
	test(2)
}
```

---
### (ì¤‘ìš”) ê³ ë£¨í‹´ì—ì„œ forë¡œ ë©”ì‹œì§€ë¥¼ ë³´ë‚¼ ë•Œ close(ch) í•„ìˆ˜
sender: messages ê°œìˆ˜ë§Œí¼ ë©”ì‹œì§€ ë³´ë‚´ê³  ëë‚¼ ê²ƒ ê°™ì§€ë§Œ ê·¸ë ‡ì§€ ì•ŠìŒ. 
receiver: ìˆ˜ì‹ ì¸¡ì˜ `for msg := range msgChn`ëŠ” msgChnì´ ë‹«í ë•Œê¹Œì§€ ê³„ì†í•´ì„œ ë©”ì‹œì§€ë¥¼ ìˆ˜ì‹ . ìƒˆë¡œìš´ ê°’ì´ ì˜¬ ë•Œê¹Œì§€ ë¬´í•œíˆ ëŒ€ê¸°.

ğŸ”¥ìˆ˜ì‹ ì¸¡ì€ goë£¨í‹´ìœ¼ë¡œ í•˜ë©´ messageResult ë¹ˆë°°ì—´ì´ ë°”ë¡œ ë¦¬í„´ë˜ì–´ë²„ë¦¼.
ë¹„ë™ê¸° ë§ê³  ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰í•´ì•¼.

```go
func processMessages(messages []string) []string {
	msgChn := make(chan string)
	go func() {
		for _, msg := range messages {
			msgChn <- msg
		}
		close(msgChn) // ğŸ”¥
	}()
	var messageResult []string
    // ğŸ”¥not go routine
	for msg := range msgChn { 
		messageResult = append(messageResult, process(msg))
	}
	return messageResult
}
```

ë‹¤ë¥¸ ì˜ˆì‹œ
```go
func main() {
	m := map[int]int{}

	mu := &sync.Mutex{}

	go writeLoop(m, mu)
	go readLoop(m, mu)

	// stop program from exiting, must be killed
    // ğŸ”¥ë‘ê°œì˜ ê³ ë£¨í‹´ì´ ë¹„ë™ê¸°ë¡œ ì‹¤í–‰ë˜ëŠ”ë™ì•ˆ ë¦¬í„´í•˜ì§€ ì•Šë„ë¡ í•¨.
	block := make(chan struct{})
	<-block
}
```

### sync.WaitGroup ë¡œ ê³ ë£¨í‹´ ì¢…ë£Œ ì „ê¹Œì§€ ë©”ì¸í•¨ìˆ˜ ëŒ€ê¸°
```go
package main

import (
	"fmt"
	"sync"
)

type Account struct {
	balance int
	Name    string
	lock    sync.RWMutex // ğŸ”´ ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ì—ì„œ ì‚¬ìš©í•¨.
}

func (a *Account) Deposit(amount int, wg *sync.WaitGroup) {
    // ğŸ”´ defer wg.Done()ë¡œ WaitGroupì˜ ì¹´ìš´í„°ë¥¼ ê°ì†Œì‹œí‚´
    defer wg.Done()

	a.lock.Lock()
	defer a.lock.Unlock()
	a.balance += amount
}

func main() {
	var wg sync.WaitGroup
	account := &Account{Name: "John Doe", balance: 1000}

	// ê³ ë£¨í‹´ì„ í†µí•´ ì…ê¸ˆ ë° ì¶œê¸ˆ ì‘ì—… ìˆ˜í–‰
	wg.Add(2)
	go account.Deposit(500, &wg) 
	go account.Withdraw(200, &wg)

	// ğŸ”´ ëª¨ë“  ê³ ë£¨í‹´ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
	wg.Wait()

	fmt.Println("Final Balance:", account.GetBalance())
}
```
