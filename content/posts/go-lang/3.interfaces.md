+++
title = 'Boot'
date = 2025-01-05T00:20:22+09:00
draft = true
+++
# Interfaces
μΈν„°νμ΄μ¤λ” λ‹¨μ§€ λ©”μ„λ“ μ‹κ·Έλ‹μ²μ μ§‘ν•©μ΄λ‹¤.
method 'signatures'κ°€ κ°™μΌλ©΄ μΈν„°νμ΄μ¤λ¥Ό κµ¬ν„ν•λ” κ²ƒμ„.

type μ΄λ¦„ interface {
    λ©”μ„λ“1() λ°ν™νƒ€μ…
    λ©”μ„λ“2() λ°ν™νƒ€μ…
}


π”΄rect, circleμ€ shapeλΌλ” μΈν„°νμ΄μ¤λ¥Ό κ°–κ³ μλ‹¤(has)
shapeλΌλ” μΈν„°νμ΄μ¤λ¥Ό κ°–κ³  μλ” κµ¬μ΅°μ²΄λ“¤μ€ λ¨λ‘ μΈμλ΅ ν—μ©ν•λ‹¤

func printShapeData(s shape) {

νƒ€μ…μ¤ν¬λ¦½νΈμ—μ„
implements = 'IS' (abstract class)
extends = 'HAS'

Goμ—μ„
interface = 'HAS'

* ν…μ¤νΈμΌ€μ΄μ¤μ—μ„ νΉμ • κµ¬μ΅°μ²΄μ— λ€μ…ν•κ³  μμ.
type testCase struct {
    emp      employee
    expected int
}
tests := []testCase{
    {contractor{name: "Jill", hourlyPay: 872, hoursPerYear: 982}}, 
    ...
}
=> contractor νƒ€μ… κ°μ²΄λ¥Ό employee νƒ€μ…μΌλ΅ μ‚¬μ©ν•λ ¤ ν•¨.

* type interface vs type struct
νƒ€μ…μ€ μΈν„°νμ΄μ¤ λ©”μ„λ“λ“¤μ„ κµ¬ν„ν•λ”λ°. λ‹¤λ¥Έ μ–Έμ–΄λ“¤κ³Ό λ‹¬λ¦¬ λ…μ‹μ μ€ μ„ μ–Έμ΄ μ—†μ. => λ¨λ“  λ©”μ„λ“λ¥Ό κµ¬ν„ν•λ©΄ μλ™μΌλ΅ μΈν„°νμ΄μ¤λ¥Ό κ°–κ²λλ”λ“―
π”Ή λ‹¨, λ¦¬μ‹λ²„λ¥Ό λ…μ‹ν•΄μ•Ό κµ¬ν„μΌλ΅ μΈμ •λ¨. μ—°κ²°μ΄ λλ ¤λ©΄
-> λ¦¬μ‹λ²„κ°€ μΈμλ΅ λ“¤μ–΄μ¨ κ²ƒμ„.
λ¦¬μ‹λ²„μ™€ λ³„κ°λ΅ μΈν„°νμ΄μ¤ λ©”μ„λ“μ— λ‹¤λ¥Έ argsλ¥Ό λ„£μ–΄λ„ λλ‹¤.

## Type Assertion
Cast to underlying type

c, ok := s.(circle)
- sλ¥Ό circle νƒ€μ…μΌλ΅ λ‹¨μ–Έ

νƒ€μ… μ¤μ„μΉμ—μ„λ§ μ‚¬μ©. vλ” eκ°€ κ²€μ‚¬λ κµ¬μ²΄μ  νƒ€μ…μΌλ΅ λ³€ν™λ κ°μ²΄.
switch v := e.(type) {
    case email: 
        return v.toAddress, v.cost()

fmt.Printf("%T\n", v) : νƒ€μ… 

func printNumericValue(num interface{}) {
- λ¨λ“  νƒ€μ…μ„ λ‚νƒ€λƒ„. 
- μ–΄λ–¤ νƒ€μ…μ κ°’μ΄λΌλ„ interface{} νƒ€μ…μ λ³€μμ— ν• λ‹Ήν•  μ

* Inherit κ°λ…
type firetruck interface {
	car // -> κ³µν†µ μΈν„°νμ΄μ¤λ¥Ό μ„λ² λ”©ν•¨.
	HoseLength() int
}

* μΈν„°νμ΄μ¤ νΉμ„±
- μΈν„°νμ΄μ¤λ” ν΄λμ¤κ°€ μ•„λ‹. μƒμ„±/ν•΄μ  λ΅μ§ ν•„μ”μ—†μ.
syntax sugarλ΅ μƒμ†μ„ ν•  μ μλ” κ²ƒ. 
- μ¤‘λ³µκµ¬ν„ ν•„μ”. κ° νƒ€μ…μ€ μμ‹ μ λ©”μ„λ“λ¥Ό μ κ³µν•΄μ•Ό 
- μΈν„°νμ΄μ¤λ” μμ‹ μ„ κµ¬ν„ν•λ” νƒ€μ…μ— λ€ν•΄ μ•„λ¬΄λ° μ •λ³΄λ„ κ°€μ§€μ§€ μ•μ
-> μμ‹ μ„ κµ¬ν„ν•  νΉμ • νƒ€μ…μ— μ ν•μ μΈ λ©”μ„λ“λ¥Ό λ§λ“¤μ§€ λ§λΌλ”.

