+++
title = '서버 API 호환성'
date = 2024-05-07T00:20:22+09:00
draft = true
+++
## 기존 서버 API 호환성

#### 🍋 셋팅 관련 몰아서 질문하기
- @UsePipes(new ValidationPipe({ transform: true }))
  - 왜 붙여야함? 어떤경우에?
- 

#### 파싱
- cheerio
  - ViaHTML로 파싱하는 경우.
    - scraper는 html만 string으로 주고
    - 파서에서 그 html를 cheerio 로드한 후 파싱한다
    - 🟣 cheerio를 파서에서 책임지는 걸로 합시다!
      - 원래는 스크래퍼 역할인 requestPage에서 $: cheerio.load로 변환 후 전달했었음. 
      - 이렇게 해도되는데 이미 scrapHelper.retrieve 함수에서 그냥 data만 전달하도록 해둔지라.. (여기에 인터셉터를 두고 html body와 함께 $ cheerio load를 같이 주도록 해도되긴 함 귀찮을듯)
```typescript
getProductDailyInfoViaHTML(html: string) {
    let body = null;
    const $ = cheerio.load(html);
```

---
#### /usage, /addable 먼저
- 둘 다 별도 유스케이스 없이 trackingPolicyService 로 바로 넘기겠음.
- 레거시 서버 연동
  - 나중에 route 새로 파고 session checker 미들웨어 넣기.
    v4 같이 어디에 정의할지 결정.
  - 레거시에 마저 추가하기
    - keyword/addable


#### example
authLegacyGuard 빼고 하기.



#### /check
💎 check 후 user tracking 자동으로 저장하지만
원래 있던 API는 호환성 위해 만들어두기 true만 리턴할지언정


#### 기타 연동 관련
router.get('/addable', async (req, res, next) => {
- 꼭 next 넣어야 하나?

쿠키: 쿠키 만료야 그렇다 쳐도 다른 유저로 로그인하면 쿠키를 만료시켜버리는건가?



#### 에러처리
throw new Error -> 는 그냥 UNKOWN 에러로 클라에 전달돼버림.
🟣 HttpException 으로 해줘야 Exception filter단에서 잡혀서 setError로 잘 나가나봄.

아니면 에러 처리할 때 
에러핸들러에서 에러 타입으로 핸들링해도 됨.


#### 외부 API 에러처리
두 가지 동작이 있음.
1. 로그를 찍는것 : data.error_msg
2. 클라이언트에 응답을 하는 것 : data.status code, 전체 data
- data에는 에러메시지, 상태코드 등이 모두 포함되어있고 콜스택도.

```javascript
res.setError = function (_err, isApiError = false) {
    if (isApiError) {
        logger.error(_err?.response?.data?.error_msg ?? _err);
        _err?.response?.data 
        ? res.status(_err.response.data.result_code).send(_err.response.data) 
        : res.setError(_err);
    }
```


