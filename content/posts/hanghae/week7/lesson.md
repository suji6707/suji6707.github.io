+++
title = 'week7 강의 필기'
date = 2025-07-09T00:20:22+09:00
draft = true
+++

🟠WEEK7 강의
I/O 비용.
페이지 단위 IOPS. 
IOPS 2000 = 8kb * 2000 = 초당 16MB 통신 가능.
🥬참고🥬 페이지는 "저장할 수 있는 공간 크기" 기준. row당 10byte면 페이지당 800 row지만 1kb면 8 row밖에 안들어감.
한 페이지가 가득차면, 새로운 페이지를 할당(생성)

레디스의 가벼움 vs DB 엔진의 복잡함.
DB는 인덱싱 메커니즘, 스키마 정의로부터 validation이 일어날거고, 그 오버헤드가 꽤 큼. -> 고비용

- mysql은 쿼리가 결과를 뽑아줄 때 복잡한 일들 - 내부에 멀티스레드로 병렬처리 등. 
- 레디스는 단일 스레드. 여러 명령어 -> 입력 그대로 . 동시성 고려 X.
만약 하나가 무거운 명령어면 기다려야. 
e.g. redis keys * : 풀스캔.. 원래 O(1)인데. 뒤 명령어들 막혀버림. 

- 레디스에도 트랜잭션이 있으나 롤백은 안됨.
MULTI ... EXEC 
- SETNX : 하나의 명령어로 묶여있어 그 하나는 원자적임.
-> 명령어 하나하나는 원자적

프로토콜 단순.
애플리케이션 -> DB.
DB는 드라이버를 다 줌. 스프링, 노드..

네트워킹.
한번의 통신을 위해 실제론 하나의 패킷이 아니라
커넥션 맺고, 인증하고 그런게 단순하면 . 

RDB는 무조건 외부에 둠. ecs 클러스터 밖. 물리적 컴퓨터를 소모.
레디스는 안에 두는 경우 많음. 
외부로 갔다오는것 = 긴 길이의 랜선을 통과한다.. 

영속성 보장하려면 RDB를 써야. 
AOF. main node를 보조하던게 승격할 수는 있는데
기본적으로 영속성 X.

---
Redis 자료구조

하나의 키 안에 많은 데이터. 512MB까지 가능.
RDB는 하나의 키로만 검색하진 않음.

mget 여러 키. 통신에 드는 레이턴시 감안. 
레디스 관점에서 네트워크는 무거움. 비중으로 봤을 때 통신비중이 크니까
mget 많이씀.

모든게 string.
INCR : 내부적으로 파싱해서 숫자 +1.
넘버 아니면 에러가 남.

sorted set
- set 안에 순서가 필요하면. 

🥬🥬<문서>🥬🥬
zadd 키 numb field : new score를 알 때.
zincrby 키 numb field : 기존 스코어에 더할때. 
-> 클릭마다. 키는 product:ranking:clicks:yyyymmdd 형식. TTL 해놓고 하루마다 집계된거 백업하는듯. 
zrange 키 0 -1 첨부터 끝까지 withscores (zrevrange : 내림차순)
zrank 키 field : 몇등 (zrevrank 내림차순 랭킹)

---
Redis 사용사례

실시간 랭킹. 
이미 sorted로 정렬되어있으므로 삽입이 logN. 풀스캔 일어나지 않음.
binary search인듯.

일단위 초기화: expire ttl 넣으면 끝.
daily 랭킹을 누적해도. 날라가게.

유저가 천만명 - 랭킹 종류가 10개다? 1억개면 부담 클 수 있음
-> 레디스 클러스터로 구성해서
랭킹 종류마다 다른 레디스 서버를 쓰도록. 

랭킹 구현
동일점수 들어오면? 
들어온 순서대로.
-> 시간 가중치. 
특정 값에서 시간값을 빼서 - 뒤에 있는 시간일수록 작은수가 나오도록.
그 값을 스코어에 붙여서. 

커머스 판매량 랭킹은 순서 상관없고,
게임 랭킹은 동일 점수라도 순서 민감.

스코어에 대한 고민. 리뷰 개수라던가, 클릭수라던가.

지금까지는 레디스를 락이나 캐시용도로만 생각했기 때문에
RDB가 있고 레디스가 그걸 받는 구조였는데.
이번엔 역으로 랭킹기능을 레디스가 구현한거고, RDB는 아무 상관이 없는.
-> 데이터의 순서가 반대일 수 있다!

시간대별로 랭킹의 변화를 보고싶다면,
한시간마다 데이터포인터(스냅샷)를 찍어 메트릭을 볼 수. 
그 정보를 RDB에 넣어놓고 그걸로 그래프를 그려보면 됨.
RDB는 로그가 적재되는 저장소로 사용, 소스는 레디스.

** 중요한 건. 
레디스라는 툴의 특징이 뭐가있고, 
'그렇기 때문에 실시간 랭킹에 레디스를 사용하면 유리하다' 는 흐름으로 가야.
그래야 다른 기능을 구현할 때 어떤 툴을 써야할지 판단할 수 있음. 

---
과제

💎설계를 먼저 하고. 전략/아이디어를 문서로 간단하게.
-> 거기에 대한 문제가 없는지 피드백 주실 것. 

1. 랭킹
빠른 매진 랭킹. 

2. 동시성 문제 - 대기열
선착순에 대한 동시성. 
레디스는 단일 스레드라 동시라는게 존재하지 않음. 
-> 신청이라는 것 자체를 레디스로 구현해버리면 해결됨.
유지보수가 쉽다는 말.

대기열 토큰
- 활성유저 관리를 sorted set으로? (set으로는 충분치 않을때)
대기표를 받고,
내 차례가 됐을 때 '지금 예매를 할 수 있는 상태다'는걸 알려주는 flag를 올려주는 활성유저 목록 관리.

sorted set으로 신청 시간을 ms로 기록할 수 있음.
list에 그냥 넣으면 시간은 알 수 없음

중복 발급 방지: set으로.
userId로 유일성.

+
레디스 직접 운영하려면. 
기술 블로그. 

