+++
title = 'week8 강의'
date = 2025-07-07T00:20:22+09:00
draft = true
+++

WEEK8 강의

이벤트 활용한 관심사 및 트랜잭션 분리
- 기능별 트랜잭션 범위 파악, 사이드 이펙트 고려
- 로직 선후관계 파악, 이벤트로 관심사 분리
- 트랜잭션 분리로 인한 문제와 해결방법

1. 트랜잭션 락의 범위
개념을 이해할 때- 문제가 발생하는 원인, 그로 인한 결과를 생각.

1) 하나의 트랜잭션이 너무 무거우면.
비즈니스 로직과 결합되면 
성능저하, 오류.
어쨌든 하나가 실패하면 롤백해야하므로 범위가 커짐..

2) DB와 무관한 작업을 수행하는 경우
API 호출이 타임아웃 걸리면.
실제로는 외부에서 정상처리됐지만
롤백이 일어나버린.

ex) 이커머스
주문결제
- 포인트 차감 > 결제정보 저장 > 주문상태 변경 > 주문정보 전파
주문정보 전파는 통계 반영, 주문완료 카카오 발송 등인데
부가작업이지 이게 실패한다고 주문결제가 실패하는건 아님.

정보 전파는 실패 로그정도만 찍고. 

BUT 문제:
중요한 트랜잭션과 부가작업들을 감싸는 로직이 더 중요한 함수가 되면서 
로직이 복잡해지고 구분하기 어려워짐.

💎 이벤트를 통한 관심사 분리. 
결합도 낮추는 대표적인 방법. 

이벤트 발행주체, 받는 주체.
기능1 -> 기능2 -> 기능3
순차적으로 생각하면 기능이 무거워지고 실패확률도 올라감.
-
1.주문 작업
2.관심상품이 할인됨을 감지하는 서비스.
3.둘다 알림톡 서비스를 호출하려함.
이걸 다 별개로 보자. 

주문작업 완료 이벤트 -> 메시지를 알림톡이 가져다가 쓰면됨.

서로 별개의 프로세스에서 작업하므로 장애 전파가 일어나지 않음.

* 이벤트 구성요소
Publisher - Even - Listener
카프카에선 Producer - Message - Consumer

* psuedo code
주문 이벤트를 리스닝하는게 여러개일 수 있음.
통계, 알람.. -> 리스너 안에서 또 별도로 이벤트 발행하는게 유리.

BUT 시스템 복잡도를 높이는 문제.
1. 보상 트랜잭션
트랜잭션을 너무 잘게 쪼개면.
내가 실패했다는 메시지를 담아 앞의 이벤트에 취소하라고 해야.

실제로 활용되는 케이스
* MSA 환경
이벤트를 통한 서비스간 약한 결합.
각 기능들을 수행하는 micro service.
주문 >> 결제 >> 재고.
별도 API임. DB도 따로있고..
이벤트 형태로 전달.

Redis pub/sub, (레디스에 능숙하다면)
카프카, (가장 대표적)
RabbotMQ,
AWS SQS

보상트랜잭션이 중요해짐.
SAGA 패턴. 
Event를 받아서 뭘 해야할지 한번에 알기가 어려움.
이벤트 리스너를 일일이 확인하고나서야 전체 프로세스를 알 수 있음.
한눈에 보려면 분리하지 않는게 나을 수도. 

- 테스트: 전체 프로세스에 대한 테스트 필요함.
- 디버깅: 두 프로세스 중 어디서 에러가 났는지 둘다 확인해야. 
🔺각각에 대해선 고민할 게 적어지는데(당연), 전체 시스템 관점에서 에러 파악하는건 난이도가 더 올라감. 
작은 서비스는 없는게 더 효율적.

큰 회사들은,
공연 예매 기능: 
상품정보 보여주는 다른 부서.
변경되면 이벤트 발행. 우리부서 뿐 아니라 다른 부서들도 리스닝함.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
* 과제
이벤트 자체 구현
- 콘서트: 예약정보
데이터 플랫폼이 있다고 가정하고 거기에 이벤트를 보내는 상황.
mock API를 만들어 호출. 
>> 이벤트를 받아서 호출, 별도의 작업으로 수행하도록!

관심사 분리에 집중!
억지스러울지라도. 하나의 기능을 작게 만드는 것.
🔺결제를 분리하면 될듯??

+ 하나의 트랜잭션들을 퍼사드로 묶어서 msa인것처럼.
실패시 보상 트랜잭션 구현(saga 처럼. best practice 찾아보기!)
필요한 프로세스 롤백하기.

배포단위를 분리한다면?
도메인 분리? 흐름제어를 깔끔하게.
-> 그에 따른 문제, 🔺깔끔하게 만들 해결방안 문서로. 

과제!! 🔺실제 서비스를 생각하며 고민을 해보는 것.
질문과 피드백
-> 문제를 고찰하는 능력을 키움

---
(참고)
### 트랜잭션에 반드시 필요한 로직이지만 외부 API를 호출하는거라면..
실무에서는 이런 상황을 다음과 같이 관리합니다:

1. 보상 트랜잭션 패턴(Compensating Transaction):
결제 실패 시 이전에 완료된 좌석 배정을 취소하는 별도의 메서드를 호출
예: if (paymentFailed) { await this.cancelReservation(reservationId); }

2. 이벤트 소싱/메시지 큐:
결제 상태를 별도로 관리하고, 결제 완료 후 최종 처리
결제 실패 시 비동기적으로 롤백 처리

3. 사가 패턴(Saga Pattern):
각 단계(좌석 예약, 결제)를 독립적인 트랜잭션으로 분리
실패 시 보상 트랜잭션을 통해 롤백

4.상태 기반 관리:
예약 상태를 더 세분화(예: SEAT_RESERVED, PAYMENT_PENDING, PAYMENT_COMPLETE)
결제 실패 시 상태를 PAYMENT_FAILED로 변경하고 나중에 정리

