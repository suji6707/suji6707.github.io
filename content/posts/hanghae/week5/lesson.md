+++
title = 'week5 강의 필기'
date = 2025-07-07T00:20:22+09:00
draft = true
+++

WEEK5 강의

여러 파드마다 db 연결하고 앞단에 로드밸런서 두는 경우,
db 락으로만 해결하기 어려움.
이 때 대부분 레디스를 씀.
서버가 하나라고 해도 여러 스레드를 만들기 때문에 동시성 이슈는 불가피함.

race condition: 락을 적절히 사용하지 않아서 발생하는 문제.
deadlock: 둘 이상 스레드가 락을 거는 순서가 꼬여서 발생.

* 이상현상
Non-repeatable Read : 해당 행의 값이 바뀐 것
Phantom REad: 여러 row의 집합이 바뀐 것. 새로운 행이 생기거나 삭제된.

* 격리수준
- Read committed(RC): 커밋된 데이터만 보여줌. 트랜잭션 중간에 다른 프로세스가 값을 바꿀 수도. 운영환경은 속도 중요하면 대부분 이거면 충분하나 - 
- Repeatable read(RR): 잔액차감, 재고감소 같이 읽은 값을 믿고 변경할 수 있어야할 때는. 
-> 트랜잭션 중에 다른 프로세스가 같은 행을 건드리는건 흔히 발생함.
@Transactional 걸어놓고 하는동안임.
같은 상품을 주문하거나. 

RR를 하기 위해 꼭 pessimistic lock을 걸어야하는건 아님. 
요즘 RDBMS는 대부분 MVCC 방식으로 RR 격리수준 구현함.
- 각 트랜잭션은 자신이 시작된 시점의 데이터 **스냅샷(snapshot)**을 보게 됨. 
- 서로를 블로킹하지 않음. 
-> read query는 데이터가 수정되는게 아니라서 베타락을 걸 필요 없음. 
read query라면 RR를 위해 select for update를 할 필요 없다는거임.
db 격리수준만 RR로 바꾸면 ㅇㅇ.

Read query 비율이 높으면(90%) 동시성 성능 극대화 가능.
- Read DB로 분산되고, 그게 동시접근 허용돼서. 물론 복제지연으로 그 커밋된 데이터가 가장 최신은 아닐 수는 있지만.
- 앞단 캐싱으로 데이터를 몰아주면 더욱 성능. '그 시점의 커밋된 데이터'를 캐시하는 RC 철학과 맞음. 
-> Master/Read DB 분리와 캐싱 전략을 함께 사용하면, 읽기 요청의 대부분을 데이터베이스까지 도달하지 않게 하거나, 복제 DB로 분산시켜 Master DB의 부담을 획기적으로 줄이고 전체 시스템의 확장성과 처리량을 극대화할 수 있습니다.

한편 쓰기가 많고 데이터 일관성 중요하면 높은 격리수준 필요함

-----
* Mysql Optimistic lock 
- version 정수형 칼럼을 두고 충돌 감지.
update query에서 WHERE version = [이전에 읽었던 버전 값], SET version += 1
-> 단일 쿼리가 아님. 처음에 select으로 version 값을 기억한채로 update 조건으로.
-> WHERE version 조건이 '조건부 업데이트'임.
- timestamp

격리 수준과 락만으로 안될때 레디스, 중복방지 토큰 등 복합적으로 활용해야.

🟢 낙관적 락은 언제 쓸만한가?
락이 걸려서 좋을게 없을때.
동시다발적으로 keyword product 테이블을 업데이트하련는 쿼리가 있는데 
select for update면 데드락 발생할 수도 있음.
+
꼭 version 칼럼을 둘 필요도 없음. 
count 같은 칼럼 값으로 repeatable read 보장할 수 있어서.
+
분산시스템:
각 MSA가 서로다른 db를 사용. 
- 주문DB 락으로는 재고DB를 제어할 수 없음
-> 낙관적 락의 경우 칼럼값을 읽어서 충돌을 감지하므로 다른 DB라도 괜찮음.!!
- 레디스, 큐 비동기 시스템은 DB락과 무관하게 작동함. 

낙관적 락은 이런 분산 환경의 특성을 고려해서 "충돌을 사후에 감지하고 처리"


-----
* DB 락에 대해
Shared lock: 동시 여러 읽기가 완료되어야 업데이트를 할 수 있다
X-lock (exclusive): 누군가 읽거나 쓰고있으면 읽기도 접근 안됨.

🔺 X lock과 db 격리수준을 동시에 사용하는 이유
- X lock은 쓰기 충돌 관리, 격리수준은 읽기 일관성 관련. 

-----
* 타임아웃 두 가지 (그냥 찾아봄) 
- lock wait timeout: 락 기다리는 대기 시간. (10초?)
- transaction timeout: 트랜잭션 유지시간. 다른 프로세스도 락을 획득해야하니까. (30초?)
🔺즉, 트랜잭션을 하는동안 스핀락을 한다고 봐야할듯??
그래서 트랜잭션에선 외부 API 처리하면 안된다는거.

메모리는 micro sec, DB는 milli sec(x1000), 외부 API 호출은..ㅋㅋ(x10000?)


-----
* 포인트 차감 - Ledger(원장)방식
모든 돈의 출입을 append하고, 합계가 잔액. 
포인트가 마이너스가 되는 상황은 race condition -> X lock으로 해결 가능하지만 '병렬 처리'가 안됨. -> 아예 balance 필드를 없애버리고 ledger 테이블 만듦.

-----
* 동시성 테스트
시스템 출시 전 락 경합을 테스트해보고 출시해야함.


* mysql 격리수준 repeatable read인데. update문은 알아서 잠금 처리한다?
그래도 read가 되냐 안되냐의 차이가 있을거라.
REPEATABLE READ 격리 수준이라도, 트랜잭션이 데이터를 변경하기 전까지는 다른 트랜잭션이 해당 데이터를 읽을 수 있습니다. 그리고 UPDATE 문이 실행되는 시점에는 잠금이 발생하여 동시 수정은 막지만, 순차적으로는 실행될 수 있습니다.
-> 현재 상황: 두 트랜잭션이 거의 동시에 시작하여 둘 다 status가 AVAILABLE인 것을 확인한 후, 순차적으로 UPDATE를 시도하기 


@seat.prisma.repository.ts#L26-41 두번째 시도가 status=1로 바뀐후라 status=0 조건에서 실패했다면 에러가 발생해야하는데 왜 updated seat@seat.prisma.repository.ts#L38 가 출력되지?