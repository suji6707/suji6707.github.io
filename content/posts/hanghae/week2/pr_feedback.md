+++
title = 'week2 PR 피드백'
date = 2025-07-07T00:20:22+09:00
draft = true
+++

### WEEK2 다른 사람들 피드백 참조

# 느낀점
다들 좌석예약 경합만 redis를 썼는데
대기열이 큐고 worker가 일을 하는 구조는 생각 안한듯.

# 내꺼 피드백
1. TTL 만료 race condition 발생 가능성: 사용자가 느리게 동작할 경우 paymentToken이 만료되기 전에 결제를 완료하지 못하는 경우가 생길 수 있음.

사용자가 결제 정보를 입력하고 "결제하기" 버튼을 누르는 시점이 4분 59초라고 가정합니다.
클라이언트에서 서버로 결제 요청이 전송되는 동안 네트워크 지연 등으로 시간이 약간 더 소요됩니다.
서버가 요청을 받아 paymentToken의 유효성을 Redis에서 확인하는 시점에는 이미 5분이 지나 토큰이 만료된 상태일 수 있습니다.

대응 방안:
클라이언트 측 타이머와 약간의 버퍼: 클라이언트 UI에 표시되는 만료 시간보다 서버 측 TTL을 약간 더 길게 설정하여 네트워크 지연 등을 감안합니다. (예: UI 5분, 서버 TTL 5분 10초)

2. 현재 시퀀스 다이어그램에서는 토큰 자체는 단순 식별자(UUID 등)이고, 토큰에 대한 상태나 정보(누구의 것인지, 어떤 용도인지, 언제까지 유효한지 등)는 Redis에 별도로 저장하는 방식입니다 (Stateful Token). -> Stateless Token 방식 중 하나인 JWT(JSON Web Token)의 도입을 고려해보라

JWT 구조: 헤더(Header), 페이로드(Payload), 서명(Signature) 세 부분.
- payload에 
1) clientId(userId), 
2) actionCode(어떤 행동을 위해 발급되었는지, scope/purpose): queue_entry (대기열 진입용), seat_reservation_payment (좌석 예약 결제용)
3) exp: JWT 표준
4) 기타: concertId, seatId 등

JWT 자체에 필요한 정보(만료 시간, 사용자 식별, 용도 등)가 저장되어있으면 Redis에 토큰 관련 정보를 저장할 필요가 없어짐! 
Redis 조회 오버헤드가 줄어들고, 서버가 상태를 관리할 필요가 없어 수평 확장에 유리


"Redis에만 저장하되, 최소한 token scope 및 의도된 사용 목적을 저장하도록 구조 확장 추천"
{
  "userId": "user123",
  "concertUuid": "concert_abc",
  "status": "PROCESSING", // WAITING, PROCESSING, EXPIRED 등
  "purpose": "QUEUE_ENTRY_ACCESS", // 토큰의 사용 목적 명시
  "createdAt": "timestamp",
  "expiresAt": "timestamp" // TTL과 별개로 애플리케이션 레벨 만료 시간
}

3. MSA와 결제서비스 멱등성
멱등성과의 관계: 멱등성을 보장하기 위해서는 각 결제 요청의 처리 상태(시작, PG 요청 중, 성공, 실패, 재시도 중 등)를 정확하게 추적하고 기록해야 합니다. MSA로 분리되면 결제 서비스는 이러한 상태 관리에 최적화된 데이터 저장소를 독립적으로 운영하여, 중복 요청이 왔을 때 이전 처리 상태를 빠르게 확인하고 적절히 대응할 수 있습니다.

구체적 예시 (중복 결제 방지):
-클라이언트가 결제 요청 (요청 ID: req_123, 주문 ID: order_abc).
-결제 서비스는 req_123을 받고, order_abc에 대한 결제 처리 상태를 "시작됨"으로 기록 (자체 DB 또는 Redis 등에).
-PG사에 결제 요청.
-네트워크 문제로 클라이언트가 응답을 못 받고, 동일한 요청 (req_123, order_abc)을 다시 보냄.
-결제 서비스는 req_123을 다시 받았지만, 이미 "시작됨" 상태임을 확인하고, PG사에 중복 요청을 보내지 않고 이전 처리 결과를 기다리거나, 이미 성공했다면 성공 응답을 다시 전달합니다.

+ 외부 시스템과의 통신 실패는 재시도를 유발하고, 이는 멱등성 보장의 필요성을 더욱 높입니다. 결제 서비스가 이러한 시나리오에 집중하여 멱등성 키(Idempotency Key, 예: 클라이언트가 생성한 고유 요청 ID)를 기반으로 요청을 처리하도록 설계하면, 재시도 시에도 안전하게 동일한 결과를 보장할 수 있습니다.

구체적 예시 (실패 복구 및 재시도):
-결제 서비스가 PG사에 요청했으나 타임아웃으로 실패.
-결제 서비스는 해당 요청 상태를 "PG 실패 - 재시도 예정"으로 기록하고, 멱등성 키와 함께 재시도 큐에 넣습니다.
-백그라운드 워커가 재시도 큐에서 작업을 가져와 멱등성 키를 확인하며 다시 PG사에 요청. 만약 이전에 이미 성공한 기록이 있다면 (네트워크 문제로 응답만 못 받은 경우), 중복 처리하지 않고 성공으로 간주.

+🍎이벤트 기반 아키텍처와의 시너지 (Pub/Sub):
BullMQ와 같은 메시지 큐를 사용하는 Pub/Sub 구조는 비동기 처리에 매우 효과적입니다.
예시: 결제가 성공하면, 결제 서비스는 "결제 성공 이벤트"를 메시지 큐에 발행(Publish)합니다. 주문 서비스, 알림 서비스 등 다른 MSA들은 이 이벤트를 구독(Subscribe)하여 각자의 후속 처리를 진행합니다.

멱등성과의 관계: 이벤트 기반으로 처리하면, 각 서비스는 자신이 받은 이벤트에 대해서만 멱등하게 처리하면 됩니다. 만약 메시지 큐 시스템이 "at-least-once delivery" (최소 한 번 전달)를 보장한다면, 동일한 이벤트가 여러 번 전달될 수 있습니다. 이 경우 이벤트를 소비하는 서비스(예: 주문 서비스)는 이벤트 ID 등을 사용하여 이미 처리한 이벤트인지 확인하고 중복 처리를 방지해야 합니다 (소비자 측 멱등성). 결제 서비스 자체가 MSA로 분리되어 있으면, 이러한 이벤트 발행 및 구독 로직을 더 명확하고 안정적으로 관리할 수 있습니다.

+ MSA는 특화된 기술 스택 및 데이터 저장소 선택 가능:
예시: 결제 트랜잭션 로그는 매우 중요하며, 특정 시점의 상태를 정확히 기록하고 빠르게 조회할 수 있어야 합니다. 결제 서비스 MSA는 이러한 요구사항에 맞춰 특화된 데이터베이스(예: 이벤트 소싱에 적합한 DB, 또는 고성능 트랜잭션 처리에 유리한 DB)를 선택할 수 있습니다.

# 카프카
Kafka는 Redis를 '대체'하기보다는 역할이 다릅니다.
Kafka는 아래와 같은 용도로 더 적합합니다:
🔺예약 요청 이후의 이벤트 처리 분리 (예: 예약 성공 → 좌석 배정, 결제 시스템 연동, 알림 발송 등)
대기열 순서 자체를 보장하기보다는, 비동기 이벤트 전파와 로그 기반 재처리에 강점이 있음
따라서 Redis는 실시간 순차 제어(대기열, 락)에 그대로 사용하시고, Kafka는 비동기 처리 및 확장 이벤트 트리거용으로 함께 가져가는 구조가 일반적입니다.

# 대기열 개선사항
- 실제 운영 환경에서는 🔺대기열 이탈(예: 브라우저 종료, 비정상 종료) 시 처리나, 특정 시간 동안 반응 없는 사용자 제거 처리 등이 함께 설계되어야 안정성이 확보됩니다.
-> Q. 대기열을 자발적으로 나간걸 서버에서 어떻게 인식하고 job exit 하지?
- 반복 polling 조건에서 "순위 5 미만"이라는 기준도 괜찮지만, 실시간 트래픽이 많은 경우에는 웹소켓 기반 push 구조도 고려해볼 수 있습니다.

# idempotency key
결제에 대한 외부 PG 연동을 고려하고 있다면, idempotency key와 🔺결제 실패 후 롤백 정책도 미리 정의해두면 좋습니다.
(참고)
클라이언트가 “idempotency-key”를 발급(생성/전송)하고, 서버가 이를 저장
보통 Header 또는 Body 파라미터로 날림
(예: x-idempotency-key: 1234-5678-abcd)
서버는 해당 idempotency key가 이미 저장된 적 있는지 Redis에서 조회.

# 레디스 활용한 좌석 배성
대기열 큐 구조나 좌석 lock 등에는 Redis가 적합하게 사용되었습니다.
좌석 Lock은 SETNX + TTL 방식 또는 Redis의 Redlock을 통해 경합을 방지할 수 있습니다.
TTL을 활용한 5분간 좌석 lock 방식도 현실적으로 적절합니다. 
🔺🔺단, TTL 만료 후 자동 해제가 보장되도록 확인 로직이 필요합니다.
-> HOW?? 나의 경우 임시 결제 토큰이 발급되고 5분 후 만료되는데. 그때 DB reservation 및 seat 의 값을 다시 되돌려놓아야함. 
(5분 뒤에 깨어서 결제가 일어나지 않은 경우 DB 값을 바꾸고 exit하는 task를 백그라운드로 돌림)

# seat lock 테이블이 필요없음
SET lock:seat:<seat_id> <unique_lock_value> NX EX <lock_timeout_seconds>
NX: 키가 존재하지 않을 경우에만 SET 명령을 실행합니다. 즉, 아무도 락을 잡고 있지 않을 때만 락을 획득할 수 있습니다.

(참고)
레디스는 클라이언트마다 연결은 각각 있을 수 있어도,
read/write 쿼리는 단일 메인스레드에서 실행됨.
마치 node처럼 싱글스레드로 큐에 요청을 쌓아두고 하나씩 꺼내어 처리.
I/O가 많은 애플리케이션들은 이런식으로 처리 많이함.
한편 CPU intensive한 애플리케이션(db)들은 멀티 스레드로 동작하는 경우 많고. 

NX 옵션을 전달하면 SET 하려는 키가 없는 경우에만 SET이 성공한다. Redis는 싱글 스레드로 동작하기 때문에 여러 프로세스가 공유 자원에 접근할 때 발생하는 동시성 문제를 이 명령어로 해결할 수 있다.
🔺🔺여기서 다른 쓰레드들이 대기하도록 while 문과 같은 루프와 Sleep같은 함수는 개발자가 직접 제공해야 한다.

# 응답 code 정의 확실히
토큰 존재 X, 만료, 잘못되었을 시: 401 Unauthorized
좌석 정보 찾을 수 없음: 404 Not Found
좌석 정보 - BLOCKED, ASSIGNED: 400 Bad Request
락 획득 실패: 409 Conflict

# 로깅 / 인프라
로그 수집 및 모니터링(AWS CloudWatch, Grafana 등)에 대한 언급은 없었지만, 운영 환경에서는 ELK 또는 Cloud-native 로그 수집/모니터링 도구 연계도 중요합니다.
추후 AWS나 Azure에 배포한다는 가정하에 🔺public/private망을 분리

로그 수집 (ELK 스택) 구성이 포함된 점 좋았습니다. 이후 🔺로그 원본 저장소에 대한 s3도 구성되면 더욱 좋을 것 같습니다.
Redis는 장애 발생 시 영향도가 크므로 🔺Redis Sentinel 또는 AWS ElastiCache Multi-AZ 구성도 함께 고려해보시면 좋을 것 같아요.



🔺사용자 행동 기반 로그 저장 및 분석(예: 예약 성공률, 실패율 등)을 위한 이벤트 로그 구조도 장기적으로 도움이 됩니다.


# 이커머스
- 2. 인기 상품 조회
인기 상품 조회시 3일치 데이터를 조회하는데요
대규모 서비스라면 3일치 데이터 조회가 실시간으로 이루어지지 않을 확률이 큽니다
따라서 작성해주신 것 처럼 통계를 내는 배치 잡 또는 스트림이 필요한데요

🔺추가로 CMS(count-min sketch) 또는 Bloom Filter 와 같은 확률적 자료구조를 통해서도 구현이 가능합니다


