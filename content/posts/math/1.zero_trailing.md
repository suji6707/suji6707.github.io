+++
title = '중학수학 올림피아드'
date = 2024-08-06T00:20:22+09:00
draft = true
+++
### Zero_trailing
2017!
```javascript
function trailingZeros(n) {
    let count = 0;
    
    // 5의 거듭제곱으로 나누면서 count를 증가시킵니다.
    for (let i = 5; Math.floor(n / i) > 0; i *= 5) {
        count += Math.floor(n / i);
    }
    
    return count;
}

// 2017 팩토리얼의 trailing zero 개수를 계산합니다.
console.log(trailingZeros(2017));  // 출력: 502
```

2는 5보다 훨씬 많다.

Q. 625의 경우 5로 나눌 때 한번 카운트되고 5^2로 나눌때 한번 더 카운트되는게 아니라,
5로 나눌때 +1 카운트, 다음번 한번더 5로 나눌때 +1, 다음번 +1, 다음번 +1 인거임.
기본적으로 0의 개수 k는 2^k x 5^k의 쌍인데,
꼭 2^4 x 5^4가 <= 2017이어야한다는 게 아니라
5^4가 어쨌거나 5가 4개로 구성된 수이기에 
5로 나눈 한 번의 카운트가 아니라, 5를 한번씩 더 나눠줌으로써 총 4번으로 카운트되어야 한다는 말.

네, 좋은 질문입니다! 말씀하신 부분이 바로 이 알고리즘이 가진 중요한 포인트 중 하나입니다. 625는 5로 네 번 나누어질 수 있지만 (625 = 5 * 5 * 5 * 5), trailing zero의 개수를 정확하게 계산하기 위해 각 단계에서 **추가적으로** 얼마나 5가 포함되는지 확인해야 합니다.

* 5로 나눌 때: 625는 한 번 나누어지므로 1을 더합니다.
* 25(5^2)로 나눌 때: 625는 한 번 더 나누어지므로 1을 더합니다. 
* 125(5^3)로 나눌 때: 625는 한 번 더 나누어지므로 1을 더합니다.
* 625(5^4)로 나눌 때: 625는 한 번 더 나누어지므로 1을 더합니다.

각 단계에서 단순히 625가 5의 거듭제곱으로 나누어지는 횟수를 더하는 것이 아니라, 각 단계에서 **새롭게** 나타나는 5의 개수를 세는 것이 중요합니다. 

결과적으로 625는 최종적으로 4개의 trailing zero에 기여하게 되는 것입니다. 이 알고리즘은 이러한 점을 정확하게 반영하여 작동합니다. 

만약 625를 한 번에 처리하여 4를 더한다면, 125, 25, 5 각각에 대해서도 똑같이 4를 더해야 할 것입니다. 그렇게 되면 5의 개수를 중복 계산하게 되어 잘못된 결과를 얻게 됩니다. 


