+++
title = '이산수학'
date = 2024-08-06T00:20:22+09:00
draft = true
+++
# 이산수학

---
### 구글 로그인시 callback에 state 담기
목표: 16자리 16진수를 만든다.

```js
// 1. SERVER Node 전용
const state = randomBytes(16).toString('hex')

// 2. CLIENT 전용
const googleLogin = () => {
  const array = new Uint8Array(16);
  crypto.getRandomValues(array);
  const state = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
  
  // 나머지 로직...
}
```
💎 배열의 각 바이트를 16진수 문자열로 변환하고, 필요한 경우 앞에 0을 붙여 2자리로 만듭니다
네, 좋은 질문입니다. 1바이트와 16진수 표현에 대해 자세히 설명해 드리겠습니다.

1. 1바이트가 255까지인 이유:
   - 1바이트는 8비트로 구성됩니다.
   - 8비트로 표현할 수 있는 가능한 조합의 수는 2^8 = 256개입니다.
   - 이 256개의 값은 0부터 255까지의 숫자로 표현됩니다 (0을 포함하므로 255까지).

2. 2자리 16진수로 표현되는 이유:
   - 16진수는 0부터 15까지를 한 자리로 표현합니다 (0-9, A-F).
   - 2자리 16진수는 16 * 16 = 256가지의 값을 표현할 수 있습니다.
   - 이는 정확히 1바이트가 표현할 수 있는 값의 범위와 일치합니다.

예시:
- 십진수 0 = 이진수 00000000 = 16진수 00
- 십진수 15 = 이진수 00001111 = 16진수 0F
- 십진수 16 = 이진수 00010000 = 16진수 10
- 십진수 255 = 이진수 11111111 = 16진수 FF

몇 가지 더 구체적인 예:
1. 십진수 42
   - 이진수: 00101010
   - 16진수: 2A

2. 십진수 167
   - 이진수: 10100111
   - 16진수: A7

3. 십진수 255 (최대값)
   - 이진수: 11111111
   - 16진수: FF

4. 십진수 0 (최소값)
   - 이진수: 00000000
   - 16진수: 00

이렇게 1바이트의 모든 가능한 값(0-255)은 항상 두 자리 16진수(00-FF)로 표현될 수 있습니다. 이는 데이터를 간결하고 일관된 형식으로 표현하는 데 유용합니다.