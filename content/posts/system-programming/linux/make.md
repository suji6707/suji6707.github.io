+++
title = 'Make'
date = 2024-12-30T00:20:22+09:00
draft = true
+++
# Make

If any file's dependencies changes, then the file will get recompiled.
컴파일러는 파일이 변경되었을 때만 파일을 컴파일 해야하는데,
이를 위해 filesystem timestamp를 변경여부 판단 프록시로 쓴다.
파일이 변경될 때만 타임스탬프가 변하므로 합리적.


---
## 컴파일 작동방식

이 설명은 Linux 및 유닉스 계열 시스템에서 C 프로그램이 컴파일되는 과정을 설명합니다. 각 단계는 소스 코드가 최종 실행 파일로 변환되는 과정을 보여줍니다. 여기서는 `gcc`와 `cpp`의 역할을 포함하여 각 단계가 어떻게 진행되는지 설명합니다.

### 컴파일 과정:

1. **전처리 (cpp)**:
   - `cpp`는 C 전처리기로, `.c` 파일과 `.h` 파일을 받아들여 전처리된 `.i` 파일을 생성합니다.
   - 이 과정에서는 `#include` 지시문을 통해 포함된 파일의 내용을 확장하고, `#define`으로 정의된 매크로를 실제 값으로 대체합니다.

2. **컴파일 (gcc)**:
   - `gcc`는 전처리된 `.i` 파일을 받아 어셈블리 소스 코드인 `.s` 파일을 생성합니다.
   - 이 단계에서는 고급 언어인 C 코드를 어셈블리 언어로 변환합니다.

3. **어셈블리 (as)**:
   - `as`는 어셈블러로, `.s` 파일을 받아 객체 파일인 `.o` 파일을 생성합니다.
   - 객체 파일은 기계어 코드의 조각으로, 아직 주소가 확정되지 않은 심볼(변수나 함수의 주소)을 포함하고 있습니다.

4. **링킹 (ld)**:
   - `ld`는 링커로, 여러 개의 `.o` 파일과 필요한 라이브러리를 결합하여 실행 파일을 생성합니다.
   - 이 과정에서 심볼의 주소를 확정하고, 모든 참조를 해결합니다.

5. **실행 파일 생성**:
   - 기본적으로 생성된 실행 파일의 이름은 `a.out`입니다. 이는 과거 어셈블러의 출력 파일 이름에서 유래되었습니다.
   - `-o` 옵션을 사용하여 실행 파일의 이름을 지정할 수 있습니다.

6. **라이브러리 관리 (ar, ranlib)**:
   - `.a` 파일은 여러 `.o` 파일을 포함하는 라이브러리 파일입니다.
   - `ar` 명령어를 사용하여 라이브러리를 관리하고, `ranlib`을 사용하여 심볼 테이블을 생성하여 컴파일 속도를 높일 수 있습니다.

7. **최적화 (strip)**:
   - `strip` 명령어를 사용하여 실행 파일에서 디버깅 정보를 제거하여 파일 크기를 줄일 수 있습니다.

### `gcc`와 `cpp`의 역할:

- **`gcc` (GNU Compiler Collection)**:
  - C, C++, 그리고 다른 여러 프로그래밍 언어를 위한 컴파일러입니다.
  - 소스 코드를 기계어로 변환하여 실행 가능한 프로그램을 생성합니다.
  - 여러 단계를 자동으로 처리하여 사용자가 쉽게 컴파일할 수 있도록 합니다.

- **`cpp` (C PreProcessor)**:
  - C 소스 코드의 전처리를 담당합니다.
  - 매크로 확장, 파일 포함, 조건부 컴파일 등을 수행합니다.

이러한 과정을 통해 C 프로그램은 소스 코드에서 실행 가능한 바이너리 파일로 변환됩니다. `gcc`는 이러한 모든 단계를 자동으로 처리하여 사용자가 간단한 명령어로 프로그램을 컴파일할 수 있도록 도와줍니다.

- `gcc foo.c baz.c -o baz` 명령어는 `foo.c`와 `baz.c` 두 개의 C 소스 파일을 컴파일하고, 그 결과를 링크하여 `baz`라는 실행 파일을 생성합니다.
- `-o baz` 옵션은 생성된 실행 파일의 이름을 `baz`로 지정

---
## Libraries

라이브리는 여러 프로그램에서 재사용할 수 있는 코드의 집합입니다. 라이브러리는 크게 두 가지 유형으로 나뉩니다: 정적 라이브러리와 동적 라이브러리.

1. **정적 라이브러리 (.a 파일)**:
   - 정적 라이브러리는 컴파일 시 프로그램에 포함되어, 실행 파일의 일부가 됩니다.
   - `ar` 명령어를 사용하여 객체 파일(.o)을 모아 정적 라이브러리(.a)를 생성합니다.
   - `ranlib` 명령어는 라이브러리의 심볼 테이블을 생성하여 컴파일 속도를 높입니다.
   - 프로그램을 컴파일할 때 `-L` 옵션으로 라이브러리 경로를 지정하고, `-l` 옵션으로 라이브러리 이름을 지정하여 링크합니다.

   예:
   ```bash
   gcc foo.c -c -o foo.o
   ar rcs libs/libfoo.a foo.o
   ranlib libs/libfoo.a
   gcc baz.c -Llibs/ -lfoo -o baz
   ```

2. **동적 라이브러리 (공유 라이브러리, .so 파일)**:
   - 동적 라이브러리는 프로그램 실행 시 로드되며, 여러 프로그램 간에 공유될 수 있습니다.
   - `-shared`와 `-fPIC` 옵션을 사용하여 공유 라이브러리를 생성합니다. `-fPIC`는 위치 독립 코드(Position Independent Code)를 생성하여, 라이브러리가 메모리에 로드될 때 재배치 없이 사용할 수 있도록 합니다.
   - `dlopen` 함수를 사용하여 실행 중에 동적 라이브러리를 로드할 수 있습니다.

   예:
   ```bash
   gcc foo.c -shared -fPIC -c -o foo.o
   ```

라이브러리는 코드의 재사용성을 높이고, 프로그램의 크기를 줄이며, 유지보수를 용이하게 합니다. 
🔴 정적 라이브러리는 모든 코드가 실행 파일에 포함되므로 독립적으로 실행할 수 있지만, 동적 라이브러리는 실행 시 라이브러리가 필요합니다.