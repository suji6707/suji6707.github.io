+++
title = 'Lecture3'
date = 2025-01-22T00:20:22+09:00
draft = true
+++
# File IO PPT

3p.
디바이스는 화면, 키보드, 마우스 다 file을 통해서 .
interprocess는 성격이 다른데 file임.

8.
파일이라기보단 "파일 스트림"을 여는 것.
EOF 만날때까지 바이트를 읽는.
한글자씩 스트림으로.

put, get이 있으면 character oriented,
c는 char, s는 string 기반 동작.

버퍼에 쓰기. 어떤 타입을 몇개 읽을건지. 보통 버퍼의 길이 - 1

fprintf: 파일에 print, 
fscanf: 파일로부터 scanf. 파싱을 포멧에맞게 할수있음.

버퍼사이즈만큼 읽고 씀. 
계속 length 업데이트 시켜가면서.

15.
whence: 오프셋 기준. 앞,뒤,현재
파일을 전체 다 읽을필요 없을때.

17.
다 블록단위로 읽고 쓸건데,
그렇다 하더라도 실제 주소는 바이트 단위.
바이트단위는 오버헤드가 높아서 커널단에서 버퍼를 씀.
버퍼를 씀으로써 한글자씩 읽고쓰는데 들 시간을 다른 일에 yield 할 수 있음.
닫아줘야함.

18. 
Why give user an integer instead of a pointer to the (open) file description in kernel?
오픈파일디스크립션이 커널이 실제로 파일에 접근하는 테이블이고
그것을 직접 참조하는 포인터가 아닌 integer인 파일 디스크립터를 반환함으로써 abusing 못하게 보호한다. 

19.
파일디스크립터와 파일 포인터간에는 변환이 가능.
fileno, fdopen 

20.
read가 반환한 byte수만큼 lseek으로 옮겨놓고 또 read 하고..

23.
버퍼에 읽고 쓰는동안 프로세스는 다른 일을 할 수 있고,
write는 백그라운드에서 완료, 커널에 주고 난 후 유저에게로 돌아온다.

디스크 캐싱도 버퍼링의 일종임.
램에다 쓰고 디스크에 저장하는.

26.
- fread: 파일 포인터를 받음. 안에 파일디스크립터가 있음. -> 한번 더 추상화한. 내부에 offset을 따로 갖고있고. low level의 lseek가 high level의 offset과 별도라고 했고. 
- read: 파일디스크립터를 받고

27.
fwrite를 했더라도 flush를 해줬다면 반드시 b일텐데
보장할 수 없음.
명시적으로 fflush
or fclose가 flush를 해주기 때문에 반드시.

시스템콜을 직접 부르면 변경사항이 적용됨.
high-level에서 버퍼를 쓸 뿐.

syscall은 비싸기 때문에 버퍼를 씀.
버퍼링 이용한 fgetc는 훨씬 크게 읽어옴. 
버퍼에 가져오고 읽은척 .

34. 
newline - 시스템이 아니라 high-level IO가 구분해서 가져오는거임.


37.
모든 열린 파일을 유닉스 OS 차원에서 관리.


50.
ofd가 공유되는 것의 장점:
프로세스간 커뮤니케이션할 수 있는 수단이 됨.

63. 
멀티스레드로 하려면 스레드로만. 멀티스레딩 안에서 fork 부르지말고.

65.
섞어쓰면 안됨.
유저레벨 버퍼랑 커널레벨 버퍼 인덱스는 다름.
fread는 10 byte만 읽은것처럼 표현하지만
파일디스크립터 내부- 커널수준의 인덱스는 블록만큼 읽혀있음.

---
# Discussion

각 프로세스는 다른 fd 번호를 가질 수 있음
하지만 같은 File Description을 가리킬 수 있음




---
### 내 메모
File I/O
시스템콜 대신 라이브러리. 
라이브러리는 버퍼링(buffering)을 통해 성능을 향상시킬 수 있습니다. 작은 크기의 읽기/쓰기 작업을 모아서 더 큰 블록 단위로 시스템 호출을 수행.

파일은 bytes다.
어떤 포멧이든 바이트로 다룸.
커널은 read/write시 내부적으로 버퍼를 쓴다.
- 캐싱. block을 한번에 들고온다. 
-> 유저의 bytes 단위와 disk 블록단위를 매칭시킬 수 있음.

왜 file descriptor는 그냥 숫자인가? 커널내 파일을 가리키는 포인터가 아니라?
- 보안. 유저가 커널에 직접 접근할 수 없음. 내부 테이블을 통해 가져옴. 

fopen은 내부적으로 open 시스템콜을 부르는데
FILE * 인자는 항상 file descripter 숫자를 지닌다. 


* file descriptor vs open file description
- 커널은 file descriptor와 open file description간 매핑을 유지한다. 
- 각 프로세스는 파일 디스크립터를 통해 파일에 접근하지만, 실제 파일 관리는 커널 내부의 open file description을 통해 이루어집니다.
이를 통해 커널은 파일 포인터, 접근 권한, 파일 잠금 등의 정보를 유지하고 관리할 수 있습니다.
시스템 호출은 파일 디스크립터를 받아서, 이를 통해 open file description을 찾고, 해당 파일에 대한 작업을 수행.
- 같은 fd에 대해 연속적으로 읽을 수 있는 이유는 ofd에 기록되기 때문. 

open file description 주요 필드
- inode: 어느 디스크 블록에 있는가
- loff_t: 파일내 현재 위치.

비유: 도서관
•도서관 (파일 시스템): 책(파일)들이 저장된 공간입니다.
•대출 카드 (파일 디스크립터): 회원(프로세스)에게 발급된 대출 카드입니다. 회원은 이 카드를 통해 책을 빌리고 반납합니다.
•대출 기록 (open file description): 회원이 빌린 책, 대출 기간, 반납 예정일 등의 정보가 저장된 기록입니다. 사서는 이 기록을 통해 대출 및 반납 절차를 관리합니다.

💎💎💎
* fork를 하는 경우
둘은 file descripter를 share 하므로 한쪽이 읽으면 다른쪽에도 position에 영향을 준다. 
한쪽이 close해도 다른쪽이 켜져있으면 그쪽은 그대로.

* file descriptor와 터미널 에뮬레이터 관계
HW2에 중요한 부분.
각 프로세스에는 표준 입력(0), 표준 출력(1), 표준 오류(2)에 해당하는 파일 디스크립터가 있음. 
이 파일 디스크립터들은 터미널 에뮬레이터와 연결되어 있습니다. 즉, 프로세스가 입력을 받을 때나 출력을 할 때, 이 터미널 에뮬레이터를 통해 이루어짐

프로세스 1이 셸에서 실행되는 프로세스라 할 때, fork로 프로세스 2를 생성하면 이 child는 부모의 파일 디스크립터를 상속받음. 따라서 자식도 동일한 터미널 에뮬레이터와 연결됨.

두 프로세스 모두 동일한 터미널 에뮬레이터를 사용하기 때문에, 프로세스 2가 출력을 수행하면 그 결과는 프로세스 1이 실행되던 터미널에 나타남.
이는 사용자가 셸에서 명령어를 입력하고, 그 명령어가 자식 프로세스에서 실행되더라도 출력이 동일한 터미널에 나타나는 이유

예시)
이 모두  파일 디스크립터의 상속과 터미널 에뮬레이터의 공유 덕분에 가능
- 일반 명령어
ls : 셸은 fork() 호출, 자식에서 exec() 호출해 ls 프로그램 실행함.
ls의 출력은 셸이 실행되고 있는 동일한 터미널에 나타남. 
- 파이프라인 사용:
ls | grep txt와 같은 명령어를 입력하면, 셸은 두 개의 자식 프로세스를 생성
두 프로세스는 파이프를 통해 연결되며, 최종 출력은 동일한 터미널에 나타남.
- 백그라운드 실행:
셸은 자식 프로세스를 생성하여 sleep 명령어를 실행. 이 경우, 명령어의 출력은 없지만, 프로세스가 종료되면 셸에 완료 메시지가 나타남
- 스크립트 실행:
셸은 자식을 fork해서 스크립트 실행, 자식의 스크립트 출력은 동일한 터미널에 나타남.

* 셸 프로그래밍에서 pipe로 명령어 연결하기
파일 디스크립터의 재배열과 dup 및 dup2 시스템 호출의 역할 이해
- 파이프를 사용할 때, 명령어의 출력을 다음 명령어의 입력으로 연결하기 위해 파일 디스크립터를 재배열
- pipe() 시스템 호출을 사용하여 두 개의 파일 디스크립터를 생성합니다. 하나는 파이프의 읽기 끝이고, 다른 하나는 쓰기 끝
- 예를 들어, pipe(fd)를 호출하면 fd[0]은 읽기 끝, fd[1]은 쓰기 끝이 됩니다.
- 이를 위해 dup2()를 사용하여 파일 디스크립터를 재배열 (첫 번째 명령어의 출력을 파이프의 쓰기 끝에 연결하고, 두 번째 명령어의 입력을 파이프의 읽기 끝에 연결)

dup(oldfd)는 oldfd와 동일한 열린 파일 설명을 가리키는 새로운 파일 디스크립터를 반환
dup2(oldfd, newfd)는 newfd가 oldfd와 동일한 열린 파일 설명을 가리키도록 합니다. 기존에 newfd가 가리키던 파일 설명은 닫힘. (old를 new에 복사한다)

---
질문중 
* 멀티스레드 프로세스에서 fork()를 한다면?
- 프로세스1에 스레드 1,2 두 개가 있고
fork를 하면 프로세스 2에선 fork를 호출한 스레드 1만 존재.
- 문제점: 모든 스레드가 복사되지 않기에 예상치못한 문제. 모든 메모리, 파일 디스크립터는 복사되었지만 일부 스레드 자체는 실행되지 않는. 

you've got duplicates of file descriptors and address spaces but only thread 1 is still running that's unlikely what you want.
all of the memory that the threads had will still be around 
but the threads themselves won't be running.
비록 모든걸 버리고 새로운 프로세스를 얻기를 원했을지라도 말이다.

* child에서 exec()를 부르는건 안전함.
exec(): 현재 프로세스의 이미지를 새로운 프로그램의 이미지로 완전히 대체.
기존 스레드는 모두 제거되고 새로운 프로그램의 초기 스레드 하나만 생성.

* PCB (process control block)
PCB에 두 요소를 추가했음. (PCB는 운영체제가 프로세스를 관리하기 위해 사용하는 커널 내부의 자료 구조)
- 파일 디스크립터를 open file desc로 매핑
- current working dir. 
