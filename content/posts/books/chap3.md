+++
series = ['컴퓨터 밑바닥의 비밀']
tags = ['컴파일', 'CS']
title = '컴퓨터 밑바닥의 비밀 - 3장-1)저수준 계층? 메모리(사물함)에서 시작해보자'
date = 2024-04-27T00:20:22+09:00
# draft = true
+++
## 3장. 저수준 계층? 메모리(사물함)에서 시작해보자

### 3.1 메모리의 본질, 포인터와 참조

메모리라는 사물함은 1 또는 0을 보관.

메모리 읽기와 쓰기의 본질은 메모리라는 사물함에는 번호(메모리 주소)가 붙어있다는 사실을 인지하는 것. 
`$`를 붙여 값을 의미하게 할 수 있음. 

b = a
b 변수를 위해 사물함을 하나 할당해 a 변수의 숫자 데이터를 복제.
그러나 메모리가 부족해짐

#### 변수에서 포인터로
변수가 값 뿐만 아니라 메모리 주소까지 저장할 수 있게 되면서 포인터가 탄생.
포인터는 메모리 주소를 더 높은 수준으로 추상화.

능력에는 책임이 따른다.
C언어는 메모리 주소를 프로그래머가 직접 알 수 있고, 
따라서 특정 메모리 위치에 있는 데이터를 직접 조작하는 것이 가능.

#### 포인터에서 참조로: 메모리 주소 감추기
포인터는 메모리 주소를 추상화한 것이고 
참조는 포인터를 한 번 더 추상화한 것.

---
### 3.2 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?
#### 가상메모리
운영체제는 가상메모리와 물리메모리 사이의 mapping 관계만 유지함으로써
프로세스에 균일한 가상공간을 제공.

#### 페이지와 페이지 테이블: 가상에서 현실로
프로세스 주소공간을 동일한 크기의 조각(페이지)으로 나눔

---
### 3.3 스택 영역: 함수 호출은 어떻게 구현될까?

#### 함수 호출 활동을 추적하는 스택
스택은 last in first out 후입선출
스택 상단의 궤적을 살펴보면 사실상 binary tree search와도 같음.
트리 순회는 재귀 뿐 아니라 스택 구현에도 사용됨.

#### 스택 프레임 및 스택 영역: 거시적 관점
스택 프레임: 모든 함수는 실행시 자신만의 작은 상자가 필요

함수 점프와 반환
- return: 어디에서 왔는지
- jump: 어디로 가는지

기계어 관점에서 보면
call 뒤에 명령어 주소가 있고, 해당 주소는 호출된 B 함수의 첫번째 기계 명령어임.
따라서 call 직후 CPU는 B함수로 점프하게 됨

B 함수로 점프함과 동시에 B 함수의 스택 프레임이 추가됨.

#### 매개변수 전달과 반환값
매개변수 및 반환값을 가져오는 작업은 레지스터로 함.
만약 전달된 CPU 내부 레지스터 수보다 초과되면 스택 프레임에 직접 넣어서 사용할 수 있음. 

지역변수는 함수가 실행될 때 레지스터 또는 스택 프레임에 저장됨.

레지스터에 지역변수를 저장하기 전 
원래 저장되어있던 초기값을 꺼냈다가
레지스터를 사용하고 나면 다시 그 초기값을 해당 함수의 스택프레임에 저장.

스택 영역의 아래는 free segment.

---
### 3.4 힙 영역: 메모리의 동적할당
힙 영역이 필요한 이유:
지역변수는 함수를 뛰어넘어 사용하는 것이 불가능. 함수가 반환된 후에는 지역변수가 저장되어있던 메모리(스택프레임)가 무효화되기 때문.
그렇다면 특정 데이터를 여러 함수에 걸쳐 사용해야 한다면 힙 영역이 필요하며, 
프로그래머가 직접 해당 메모리를 할당/해제할 수 있음.

#### malloc 메모리 할당자 구현하기 / 여유 메모리 조각 관리
어떤 영역이 이미 할당된 메모리인지 구분하는 방법:
연결리스트. 

메모리 조각의 할당 정보를 추적하려면
- 해당 메모리 조각이 비어있는지 알려주는 flag
- 해당 메모리의 크기를 기록한 숫자
-> 헤드 정보 주소 + 메모리 조각 크기 = 다음 노드의 시작 주소

#### 메모리 할당하기
여유 메모리 조각을 두 개로 분할하여
앞부분은 할당 후 반환하고
뒷부분은 좀더 작은 크기의 여러 여유 메모리 조각으로 만듦




