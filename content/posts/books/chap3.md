+++
series = ['컴퓨터 밑바닥의 비밀']
tags = ['컴파일', 'CS']
title = '컴퓨터 밑바닥의 비밀 - 3장-1)저수준 계층? 메모리(사물함)에서 시작해보자'
date = 2024-04-27T00:20:22+09:00
# draft = true
+++
## 3장. 저수준 계층? 메모리(사물함)에서 시작해보자

### 3.1 메모리의 본질, 포인터와 참조

메모리라는 사물함은 1 또는 0을 보관.

메모리 읽기와 쓰기의 본질은 메모리라는 사물함에는 번호(메모리 주소)가 붙어있다는 사실을 인지하는 것. 
`$`를 붙여 값을 의미하게 할 수 있음. 

b = a
b 변수를 위해 사물함을 하나 할당해 a 변수의 숫자 데이터를 복제.
그러나 메모리가 부족해짐

#### 변수에서 포인터로
변수가 값 뿐만 아니라 메모리 주소까지 저장할 수 있게 되면서 포인터가 탄생.
포인터는 메모리 주소를 더 높은 수준으로 추상화.

능력에는 책임이 따른다.
C언어는 메모리 주소를 프로그래머가 직접 알 수 있고, 
따라서 특정 메모리 위치에 있는 데이터를 직접 조작하는 것이 가능.

#### 포인터에서 참조로: 메모리 주소 감추기
포인터는 메모리 주소를 추상화한 것이고 
참조는 포인터를 한 번 더 추상화한 것.

---
### 3.2 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?
#### 가상메모리
운영체제는 가상메모리와 물리메모리 사이의 mapping 관계만 유지함으로써
프로세스에 균일한 가상공간을 제공.

#### 페이지와 페이지 테이블: 가상에서 현실로
프로세스 주소공간을 동일한 크기의 조각(페이지)으로 나눔

---
### 3.3 스택 영역: 함수 호출은 어떻게 구현될까?

#### 함수 호출 활동을 추적하는 스택
스택은 last in first out 후입선출
스택 상단의 궤적을 살펴보면 사실상 binary tree search와도 같음.
트리 순회는 재귀 뿐 아니라 스택 구현에도 사용됨.

#### 스택 프레임 및 스택 영역: 거시적 관점
스택 프레임: 모든 함수는 실행시 자신만의 작은 상자가 필요

함수 점프와 반환
- return: 어디에서 왔는지
- jump: 어디로 가는지

기계어 관점에서 보면
call 뒤에 명령어 주소가 있고, 해당 주소는 호출된 B 함수의 첫번째 기계 명령어임.
따라서 call 직후 CPU는 B함수로 점프하게 됨

B 함수로 점프함과 동시에 B 함수의 스택 프레임이 추가됨.

#### 매개변수 전달과 반환값
매개변수 및 반환값을 가져오는 작업은 레지스터로 함.
만약 전달된 CPU 내부 레지스터 수보다 초과되면 스택 프레임에 직접 넣어서 사용할 수 있음. 

지역변수는 함수가 실행될 때 레지스터 또는 스택 프레임에 저장됨.

레지스터에 지역변수를 저장하기 전 
원래 저장되어있던 초기값을 꺼냈다가
레지스터를 사용하고 나면 다시 그 초기값을 해당 함수의 스택프레임에 저장.

스택 영역의 아래는 free segment.

---
### 3.4 힙 영역: 메모리의 동적할당
힙 영역이 필요한 이유:
지역변수는 함수를 뛰어넘어 사용하는 것이 불가능. 함수가 반환된 후에는 지역변수가 저장되어있던 메모리(스택프레임)가 무효화되기 때문.
그렇다면 특정 데이터를 여러 함수에 걸쳐 사용해야 한다면 힙 영역이 필요하며, 
프로그래머가 직접 해당 메모리를 할당/해제할 수 있음.

#### malloc 메모리 할당자 구현하기 / 여유 메모리 조각 관리
어떤 영역이 이미 할당된 메모리인지 구분하는 방법:
연결리스트. 

메모리 조각의 할당 정보를 추적하려면
- 해당 메모리 조각이 비어있는지 알려주는 flag
- 해당 메모리의 크기를 기록한 숫자
-> 헤드 정보 주소 + 메모리 조각 크기 = 다음 노드의 시작 주소

#### 메모리 할당하기
여유 메모리 조각 할당 전략
- 최초 적합(first fit)
- 다음 적합(next fit): first fit보다 빠르나 메모리 사용률은 보다 못함.
- 최적 적합(best fit): 사용가능 메모리 조각을 모두 찾은 후 요구조건을 충족하는 가장 작은 조각을 반환.

메모리 할당 시 발생하는 내부 단편화 문제 해결 방법:
- 여유 메모리 조각을 두 개로 분할하여
앞부분은 할당 후 반환하고
뒷부분은 좀더 작은 크기의 여러 여유 메모리 조각으로 만듦

메모리 해제하기
- `free` 해제 함수에 주소를 전달
- ADDR - 4byte => 헤더 정보를 알 수 있으며, 여기서 할당 설정값을 여유 메모리로 바꾸면 됨(1->0)
- 인접한 메모리 조각이 비어있으면 더 큰 메모리 조각으로 병합하기

여유 메모리 조각을 효율적으로 병합하기
- 앞에 위치한 메모리 조각이 비어있는지 알기 위해 footer를 추가. 
- footer는 조각 크기 정보와 할당여부를 지님. 


---
### 3.6 고성능 서버의 메모리 풀은 어떻게 구현될까?
메모리 풀 vs 범용 메모리 할당자
malloc은 범용 제품.
- malloc에서 메모리 풀은 응용 프로그램의 일부.
- 메모리 풀은 특정 상황에서만 최적화하기에 범용성이 매우 떨어짐

간단한 메모리 풀
- 미리 커다란 영역을 할당하고 수량은 실제 상황에 따라 결정.

더 복잡한 메모리 풀
- 메모리 풀의 여유 메모리 조각 시작위치를 가리키는 Free_ptr 포인터를 이용해 메모리 조각을 찾음

---
### 3.7 대표적인 메모리 관련 버그
지역변수 포인터 반환
- 스택프레임이 없어진 후 그 안의 지역변수를 참조할 때 버그 발생

포인터 연산의 잘못된 이해
- 포인터 연산에서 1을 더하는 것은 데이터 type 크기만큼 이동하는 것. 

문제있는 포인터 역참조
- scanf는 a 값을 주소로 취급하므로 표준입력에서 가져온 데이터를 해당 주소에 덮어씀
- a 값이 코드 영역이나 기타 읽기전용 영역을 가리키는 포인터 값이면 프로세스가 종료되나
스택 영역을 가리키는 포인터 값이라면 다른 함수의 스택 프레임을 파괴하게 됨.
- 힙 영역이나 데이터 영역 포인터 역시 프로그램의 다른 부분을 파괴할 수.

초기화되지 않은 메모리 읽기
- 메모리는 항상 0으로 초기화되지는 않음. 이전에 사용한 정보가 남아있을 수 있음.

이미 해제된 메모리 참조하기
- 힙 영역에 저장 후 해제하고
다시 해제된 메모리 조각을 참조할 때
이미 덮어쓰기가 된 데이터면 문제를 발견하기 어려워짐.

배열 첨자는 0부터 시작
- for문에서 길이 n을 초과하는, n + 1번째 할당이 이루어지려 하면 기존 메모리를 덮어쓰게 되고,
그곳에 메모리 할당 상태정보가 있다면(header / footer) malloc 동작을 파괴하게 됨.

스택 오버플로우
- gets(buf)가 정의한 바이트를 초과할 경우 인접해있던 데이터를 파괴하게 됨

메모리 누수(leak)
- 메모리 요청 후 해제 없이 바로 반환할 때 
프로세스가 종료되기 전까지 다시 해제할 방법이 없어 메모리 누수가 일어나게 됨. 

---
### 3.8 왜 SSD는 메모리로 사용할 수 없을까?
좋은 성능 SSD 읽기속도는 7.5GB/s
5세대 DDR 메모리 최대 대역폭은 60GB/s를 훨씬 넘음.

메모리와 디스크의 read/write 차이
- 메모리는 바이트 단위로, 디스크는 조각 단위로 주소가 지정됨. 

운영체제는 가상 메모리 기반.
32비트 시스템 최대 주소 지정범위는 4GB이므로 1TB SSD를 메모리로 사용한다 해도 여전히 프로세스는 4GB 이상 메모리를 사용할 수 없음.


