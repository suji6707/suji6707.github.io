+++
categories = ['Database']
series = ['Database-System']
tags = ['데이터베이스']
date = 2024-08-04T22:50:44+09:00
draft = true
+++

# Chap 13.
하나의 Page에서 일어나는 일.
사실상 대부분 Slotted Page Structure.
고정길이가 잘 없음. varchar 등

### Records in Files
heap, log file structure, index file organization 순으로 중요.

heap 을 주로 쓰는게 Postgres,
B+ index file은 MySQL.

*
트랜잭션을 할 때 
연속적 파일은 가장 최신의 row가 바쁘고 그걸 memory에 올려서 빠르게 처리하면 되는데

힙파일 구조의 경우 여러 페이지들이 바빠질거고 그걸 전부 메모리로 들고올 수는 없을 수 있으므로 느려질 수 있어보임.
-> 분리하는게 유리할 수 있음. (결론)

힙파일 구조는 아무것도 할필요가 없어서? 훨씬 빠를것 같지만(삽입/삭제시 헤더만 고쳐주면 끝) insert 성능은 mysql이랑 비슷함.
한번에 메모리에서 다 할수있는게 아니라서..

*
Storage Access
- transfer 비용이 가장 크므로 이것을 최소화하는게 가장 우선.
- 메인 메모리에 최대한 많은 block들을 keeping해서 계산해야, disk access 최소화.
-> 캐시 히트와도 관련. 

OS가 아니라 버퍼 매니저가 Buffer를 관리
데이터베이스는 스스로 OS로서 메모리를 관리하고 싶어하는데.

버퍼는 파일 캐시같은 존재.
메인메모리.

버퍼 관리자는 OS의 virtual memory와 비슷한 역할. 


DBMS 입장에서는 한 프로세스가 읽을 동안 다른 프고세스가 접근하는걸 원치 않음.
내가 읽고있는데 변형이 일어나면 안돼서.

OS에서는 서로다른 virtual memory를 가지고 같은 파일을 접근할 수 있을텐데
버퍼매니저는 don't want.
-> 그걸 매니지하는게 pined lock 등.

(목표는)
여러 프로세스들이 그 메모리를 공유자원으로 사용하게 하기 위해 shared - 를 사용.
DiskIO는 버퍼 매니저를 사용할 때 단 한 번.



--
분산 환경이면 한 테이블도 
여러 파일로 구성될 수 있고,
파일은 여러 페이지로 구성되고,
그 페이지 안에서 슬롯들로 구성. 


// 여기까지 database storage 1 내용.




힙파일 단점 - 
Update an existing tuple using its record id

그걸 개선하고자 하는게
Log-structure
대표적으로 rocksDB,levelsDB.
- 키밸류 스토리지.
어쨌든 오래된 걸 없애주는.
levelDB는 같은 레벨끼리 통폐합.

--

MySQL에서도 slotted storage 씀.

둘다 증가해야하는 구조면 반대방향으로 늘어나게 하는 구조.


---

## 정리 ======================

가변길이 레코드(Variable-Length Records)는 데이터베이스 시스템에서 다양한 길이의 데이터를 저장할 수 있는 레코드를 의미합니다. 이는 여러 가지 방식으로 구현될 수 있으며, 슬라이드에서 설명하는 slotted page structure는 이러한 가변길이 레코드를 효율적으로 저장하고 관리하는 한 방법입니다.

### 가변길이 레코드의 예시
가변길이 레코드는 다음과 같은 경우에 사용됩니다:
1. **다양한 레코드 타입 저장**: 하나의 파일에 여러 종류의 레코드 타입을 저장할 때.
2. **가변 길이 필드**: 문자열(varchar)과 같이 길이가 가변적인 필드를 포함하는 레코드.
3. **반복 필드**: 일부 오래된 데이터 모델에서 사용되는 반복 필드를 포함하는 레코드.

### Slotted Page Structure
슬라이드에서 설명하는 slotted page structure는 가변길이 레코드를 저장하는 구조입니다. 이 구조는 다음과 같은 특징을 가집니다:
- **슬롯 페이지 헤더**: 레코드 엔트리의 수, 블록 내의 여유 공간의 끝, 각 레코드의 위치와 크기를 포함합니다.
- **레코드 이동**: 레코드는 페이지 내에서 이동할 수 있으며, 이를 통해 레코드 사이에 빈 공간이 없도록 유지합니다. 이 경우 헤더의 엔트리가 업데이트됩니다.
- **포인터**: 포인터는 직접 레코드를 가리키지 않고, 헤더의 엔트리를 가리킵니다.

### 예시
예를 들어, 학생 정보를 저장하는 데이터베이스가 있다고 가정해봅시다. 각 학생 레코드는 다음과 같은 필드를 가질 수 있습니다:
- 학생 ID (정수형, 고정 길이)
- 이름 (문자열, 가변 길이)
- 전공 (문자열, 가변 길이)

이 경우, 각 레코드는 가변 길이 필드를 포함하므로 가변길이 레코드가 됩니다. 이를 slotted page structure에 저장하면 다음과 같은 방식으로 저장될 수 있습니다:

1. **슬롯 페이지 헤더**: 각 레코드의 위치와 크기, 여유 공간의 끝 등을 저장합니다.
2. **레코드 데이터**: 학생 ID는 고정 길이로 저장되고, 이름과 전공은 가변 길이로 저장됩니다. 가변 길이 필드는 실제 데이터가 저장된 위치를 가리키는 오프셋과 길이 정보로 관리됩니다.

이 구조를 통해 데이터베이스는 가변 길이 필드를 효율적으로 관리하고, 레코드의 이동과 업데이트를 용이하게 처리할 수 있습니다.


---

물론입니다! 가변길이 레코드는 각 레코드가 서로 다른 크기를 가질 수 있는 데이터 구조입니다. 이를 이해하기 위해 가변길이 레코드의 예시를 보여드리겠습니다.

### 예시: 학생 정보 데이터베이스

가변길이 레코드를 사용하는 학생 정보 데이터베이스를 예로 들어 보겠습니다. 각 학생 레코드는 다음과 같은 필드를 포함한다고 가정합니다:
- **학생 ID**: 정수형, 고정 길이 (예: 4바이트)
- **이름**: 문자열, 가변 길이 (예: 최대 50바이트)
- **전공**: 문자열, 가변 길이 (예: 최대 50바이트)

#### 학생 레코드 예시:

1. 학생 ID: 12345, 이름: "Alice", 전공: "Computer Science"
2. 학생 ID: 23456, 이름: "Bob", 전공: "Mathematics"
3. 학생 ID: 34567, 이름: "Charlie", 전공: "Physics"

### Slotted Page Structure에 저장된 가변길이 레코드

슬롯 페이지 구조를 사용하여 가변길이 레코드를 저장하는 예시를 보여드리겠습니다.

#### 슬롯 페이지 구조의 구성 요소:
- **슬롯 페이지 헤더**: 레코드 수, 여유 공간의 끝, 각 레코드의 위치와 크기를 포함합니다.
- **레코드 데이터**: 각 레코드의 실제 데이터가 저장됩니다.

#### 슬롯 페이지 예시:

```sql
+------------------+
| Slot Directory   |
+------------------+
| Record Count: 3  |
| Free Space End:  |
+------------------+
| Slot 1: Offset=100, Length=30 |
| Slot 2: Offset=130, Length=28 |
| Slot 3: Offset=158, Length=32 |
+------------------+
| Record Data      |
+------------------+
| Offset 100: [12345, "Alice", "Computer Science"] |
| Offset 130: [23456, "Bob", "Mathematics"]        |
| Offset 158: [34567, "Charlie", "Physics"]        |
+------------------+
```

### 설명:
1. **슬롯 페이지 헤더**:
   - **Record Count**: 3 (총 3개의 레코드가 저장됨)
   - **Free Space End**: 여유 공간의 끝 위치 (예: 190)

2. **슬롯 디렉토리**:
   - **Slot 1**: Offset=100, Length=30 (첫 번째 레코드의 시작 위치와 길이)
   - **Slot 2**: Offset=130, Length=28 (두 번째 레코드의 시작 위치와 길이)
   - **Slot 3**: Offset=158, Length=32 (세 번째 레코드의 시작 위치와 길이)

3. **레코드 데이터**:
   - **Offset 100**: [12345, "Alice", "Computer Science"]
   - **Offset 130**: [23456, "Bob", "Mathematics"]
   - **Offset 158**: [34567, "Charlie", "Physics"]

이 예시에서 각 레코드는 가변 길이 필드를 포함하고 있으며, 슬롯 페이지 구조를 통해 효율적으로 저장되고 관리됩니다. 슬롯 디렉토리는 각 레코드의 위치와 크기를 추적하여 빠르게 접근할 수 있도록 도와줍니다.


---

### 1. 파일 구조의 중요성
- **Heap File**: 데이터를 삽입할 때 특정 순서 없이 빈 공간에 데이터를 저장하는 방식입니다.
- **Log File Structure**: 트랜잭션 로그를 기록하여 데이터베이스의 일관성을 유지하는 구조입니다.
- **Index File Organization**: 인덱스를 사용하여 데이터를 빠르게 검색할 수 있도록 구조화한 파일입니다. B+ 트리 인덱스가 대표적입니다.

### 4. 트랜잭션 처리의 성능 비교
#### 연속적 파일 구조의 장점
- **최신 데이터 처리**: 최신 데이터가 집중적으로 사용되므로, 이를 메모리에 올려 빠르게 처리할 수 있습니다.
- **효율적 메모리 사용**: 최신 데이터만 메모리에 올리면 되므로 메모리 사용이 효율적입니다.

#### 힙 파일 구조의 단점
- **메모리 효율성 저하**: 여러 페이지에 데이터가 분산되어 있어, 모든 바쁜 페이지를 메모리에 올리기 어렵습니다.
- **성능 저하 가능성**: 메모리로 모든 페이지를 다룰 수 없을 경우, 디스크 I/O가 증가하여 성능이 저하될 수 있습니다.



---

#### Free-space Map의 구조
- **블록당 3비트**: 각 블록의 빈 공간을 나타내기 위해 3비트가 사용됩니다.
- **3비트로 표현할 수 있는 값**: 0부터 7까지 총 8개의 값이 있습니다.
  - 0: 0% 빈 공간 (완전히 사용됨)
  - 1: 12.5% 빈 공간
  - 2: 25% 빈 공간
  - 3: 37.5% 빈 공간
  - 4: 50% 빈 공간
  - 5: 62.5% 빈 공간
  - 6: 75% 빈 공간
  - 7: 87.5% 빈 공간

#### 예시 값
- 배열의 값: `4 2 1 4 7 3 6 5 1 2 0 1 1 0 5 6`
  - 각 값은 해당 블록의 빈 공간 비율을 나타냅니다.
  - 예를 들어, 값이 4인 경우: 4/8 = 0.5 (50% 빈 공간)
  - 값이 7인 경우: 7/8 = 0.875 (87.5% 빈 공간)


---
크게보면
- 어떻게 파일 안의 페이지를 구성할 것인가
- 어떻게 페이지 안의 튜플들을 저장할 것인가
   - heap file은 페이지들이 랜덤 order로 저장되고, 페이지내 튜플들도 랜덤 order로 저장됨.
- 그렇다면 random order인데 어떻게 관리하고 접근할 것인가?
   - tuple-oriented: just append
   - slotted page: 각 slot이 실제 레코드 튜플과 매핑됨.
   - 헤더는 사용된 슬롯 개수, 가장 마지막으로 사용된 슬롯 위치를 알려줌

### File Storage
힙 파일 시스템은 랜덤하게 저장되어있는.

### Page Layout
각 페이지는 메타데이터를 지닌 헤더가 있다.
페이지 안에 어떻게 데이터를 구성하는가?
1. Tuple-oriented Storage
2. Log-structured
3. Index-organized

Log-structured는 페이지내 튜플을 저장하는 대신 튜플에 대한 변화를 로그로 기록한다.
각 로그는 put, delete를 나타내고. 

---

### DiskIO와 페이지 사이즈

### MySQL이 더 큰 페이지 크기(16KB)를 사용하는 이유

예시: 한 튜플이 `int, int, varchar(32)`로 이루어진 경우

1. **튜플 크기 계산**:
   - `int`: 4바이트
   - `int`: 4바이트
   - `varchar(32)`: 최대 32바이트 (문자열 길이에 따라 다를 수 있음)
   - 총 튜플 크기: 4 + 4 + 32 = 40바이트 (최대)

2. **4KB 페이지와 16KB 페이지에서의 행 수**:
   - 4KB 페이지: 4,096바이트 / 40바이트 ≈ 102개의 행
   - 16KB 페이지: 16,384바이트 / 40바이트 ≈ 409개의 행

### 페이지 크기에 따른 스캔 효율성

- **4KB 페이지**:
  - 한 페이지에 약 102개의 행을 저장할 수 있습니다.
  - 1,000개의 행을 스캔하려면 약 10번의 디스크 접근이 필요합니다.

- **16KB 페이지**:
  - 한 페이지에 약 409개의 행을 저장할 수 있습니다.
  - 1,000개의 행을 스캔하려면 약 3번의 디스크 접근이 필요합니다.


---
<img width="595" alt="image" src="https://github.com/user-attachments/assets/2649c894-fbe3-4f7a-91cb-a8775f23d076">

### 🍋 Tuple-oriented storage - 기존 튜플 업데이트하기
기존 튜플을 업데이트할 때의 절차는 다음과 같습니다:
1. **페이지 디렉토리 확인**: 업데이트할 튜플이 있는 페이지의 위치를 찾습니다.
2. **디스크에서 페이지 가져오기**: 페이지가 메모리에 없으면 디스크에서 페이지를 가져옵니다.
3. **슬롯 배열 확인**: 슬롯 배열을 사용하여 페이지 내에서 튜플의 오프셋을 찾습니다.
4. **새 데이터가 맞는지 확인**: 새 데이터가 기존 튜플의 공간에 맞는지 확인합니다. 
   - **새 데이터가 맞는 경우**: 기존 데이터를 덮어씁니다.
   - **새 데이터가 맞지 않는 경우**: 기존 튜플을 삭제로 표시하고, 새로운 페이지에 새로운 버전의 튜플을 삽입합니다.

여기서 "new data fits"는 새로 업데이트할 데이터가 기존 튜플이 차지하고 있는 공간에 맞는지를 의미합니다. 만약 새 데이터가 기존 공간에 맞지 않으면, 새로운 페이지에 새로운 버전의 튜플을 삽입해야 합니다.

### Tuple-oriented storage 문제점
두 번째 슬라이드에서는 튜플 지향 저장 방식의 세 가지 주요 문제점을 설명하고 있습니다:

1. **문제 #1: 단편화 (Fragmentation)**
   - 페이지가 완전히 활용되지 않아서 사용되지 않는 공간이나 빈 슬롯이 생깁니다. 이는 저장 공간의 비효율성을 초래합니다.

2. **문제 #2: 쓸모없는 디스크 I/O (Useless Disk I/O)**
   - 데이터베이스 관리 시스템(DBMS)은 하나의 튜플을 업데이트하기 위해 전체 페이지를 가져와야 합니다. 이는 불필요한 디스크 입출력을 발생시켜 성능 저하를 초래합니다.

3. **문제 #3: 랜덤 디스크 I/O (Random Disk I/O)**
   - 여러 튜플을 업데이트할 때 최악의 경우 각 튜플이 다른 페이지에 있을 수 있습니다. 이는 랜덤 디스크 입출력을 발생시켜 성능 저하를 초래합니다.




---
# 실전문제
13.1
### 중요한 개념.
mysql이든 postgres든 레코드가 삭제되어도 그 공간을 즉시 채워넣기보다는 빈 상태로 둠. 
mysql은 수동으로 OPTIMIZE TABLE을 해서 disk가 재사용할 수 있도록 할 수 있는반면, postgres는 자동으로 빈번하게 vacumm을 해서 디스크공간을 반환하는듯. 

어쨌거나 둘다 slotted page 구조고,
레코드가 비어지고 다른 게 들어오게 되면 비연속적인 저장이 되는 것 아닌가?
-> 🔴 InnoDB는 B-Tree 구조를 사용하여 인덱스를 관리합니다. 그러나 인덱스가 연속적으로 저장되는 속성은 데이터 페이지가 연속적인 순서로 유지된다는 것을 의미하지 않습니다.
-> 🔴 슬롯 페이지구조내 헤더가 그 연속성을 보장하는거임.
물리적 메모리가 연속적으로 저장될 필요 없음. 

MySQL InnoDB에서 "OPTIMIZE TABLE" 명령어를 `온라인`으로 적용할 수 있다는 것은, 테이블을 최적화하는 동안 테이블에 대한 읽기 및 쓰기 작업을 계속할 수 있다.

#### mysql purge
- purge 스레드는 인덱스에서 더이상 쓸모없는 값을 제거하고, delete 쿼리에 의해 삭제되었다고 마킹된 row에 대해 물리적으로 삭제함. (marking 후 이후 purge thread가 백그라운드 스레드로 돌면서 수거하는 방식) -> soft delete도 해당되는듯
- dirty page를 flush하는 기준은 LRU(least recently used), 그 중에서 oldest. 
- 🔴 정리하자면, mysql은 purge 기능이 별도 스레드로 가비지 콜렉션 작업을 해서 어느정도 관리가 되고, 필요시 옵티마이즈를 쓸 수 있는데 온라인으로 작동해서 서비스 영향도가 아주 크진 않다 정도.

https://www.slideshare.net/slideshow/innodb-purge-deep-internal-by/79230306


13.2
파일 헤더에 당장 필요한 것은
내용이 삭제된 첫번째 레코드의 주소다. 
이 첫번째 레코드를 사용해 이용가능한 두 번째 레코드 주소를 저장하고 이런식으로 계속. 
이 삭제한 레코드는 연결리스트를 형성하며 'free list'라 불리기도 한다.

---
### 문제 13.3
Consider the relations `section` and `takes`. Give an example instance of these two relations, with three sections, each of which has five students. Give a file structure of these relations that uses multitable clustering.

#### Answer:
The relation `section` with three tuples is as follows:

| course_id | sec_id | semester | year | building | room_number |
|-----------|--------|----------|------|----------|-------------|
| BIO-301   | 1      | Summer   | 2010 | Painter  | 514         |
| CS-101    | 1      | Fall     | 2009 | Packard  | 101         |
| CS-347    | 1      | Fall     | 2009 | Taylor   | 3128        |

The relation `takes` with five students for each section is as follows:

| ID   | course_id | sec_id | semester | year |
|------|-----------|--------|----------|------|
| 001  | BIO-301   | 1      | Summer   | 2010 |
| 002  | BIO-301   | 1      | Summer   | 2010 |
| 003  | BIO-301   | 1      | Summer   | 2010 |
| 004  | BIO-301   | 1      | Summer   | 2010 |
| 005  | BIO-301   | 1      | Summer   | 2010 |
| 006  | CS-101    | 1      | Fall     | 2009 |
| 007  | CS-101    | 1      | Fall     | 2009 |
| 008  | CS-101    | 1      | Fall     | 2009 |
| 009  | CS-101    | 1      | Fall     | 2009 |
| 010  | CS-101    | 1      | Fall     | 2009 |
| 011  | CS-347    | 1      | Fall     | 2009 |
| 012  | CS-347    | 1      | Fall     | 2009 |
| 013  | CS-347    | 1      | Fall     | 2009 |
| 014  | CS-347    | 1      | Fall     | 2009 |
| 015  | CS-347    | 1      | Fall     | 2009 |

The multitable clustering for the above two instances can be taken as:

1. **Cluster 1:**
   - `section` tuple: (BIO-301, 1, Summer, 2010, Painter, 514)
   - `takes` tuples: 
     - (001, BIO-301, 1, Summer, 2010)
     - (002, BIO-301, 1, Summer, 2010)
     - (003, BIO-301, 1, Summer, 2010)
     - (004, BIO-301, 1, Summer, 2010)
     - (005, BIO-301, 1, Summer, 2010)

2. **Cluster 2:**
   - `section` tuple: (CS-101, 1, Fall, 2009, Packard, 101)
   - `takes` tuples:
     - (006, CS-101, 1, Fall, 2009)
     - (007, CS-101, 1, Fall, 2009)
     - (008, CS-101, 1, Fall, 2009)
     - (009, CS-101, 1, Fall, 2009)
     - (010, CS-101, 1, Fall, 2009)

3. **Cluster 3:**
   - `section` tuple: (CS-347, 1, Fall, 2009, Taylor, 3128)
   - `takes` tuples:
     - (011, CS-347, 1, Fall, 2009)
     - (012, CS-347, 1, Fall, 2009)
     - (013, CS-347, 1, Fall, 2009)
     - (014, CS-347, 1, Fall, 2009)
     - (015, CS-347, 1, Fall, 2009)

이렇게 하면 각 섹션과 해당 섹션을 듣는 학생들의 정보를 클러스터링하여 저장할 수 있습니다.

---









