+++
categories = ['Database']
series = ['Database-System']
tags = ['데이터베이스']
title = "인덱스"
date = 2024-05-09T22:50:44+09:00
draft = true
+++
## Indexing

#### 순서 인덱스(Ordered Index)

#### 해시 인덱스(Hash Index)


---
키와 인덱스는 묘하게 다름.
키는 유니크 느낌이 강하고
인덱스는 non-unique도 많음. 

#### 클러스터링 인덱스 (primary index) = 주로 PK
클러스터링 인덱스는 파일이 특정 순서로 정렬되어 있을 때, 그 순서를 지정하는 검색 키를 사용하는 인덱스.
걍 PK라 보면 됨. (클러스터링 인덱스는 테이블당 하나만 생성할 수 있음)

프라이머리 인덱스는 주로 PK. 
- 프라이머리 인덱스에 의해 레코드 저장 위치가 결정됨 🔺
- 보조 인덱스로 검색할 때 프라이머리 인덱스로 다시 한번 검색해야 함


#### 보조 인덱스 (nonclustering)
파일의 연속적인 순서와 다른 순서로 구성되는 검색 키의 인덱스.

검색키가 주 키(ID)가 아니라 dept_name인 경우.
instructor 파일이 ID 대신 dept_name 순으로 정렬.
dense index를 사용하면 
'Bioloy' 레코드에 대한 포인터를 따라가서 dept_name대로 Biology가 아닌 레코드가 나올 때까지 처리.

dense index가 sparse 보다 더 빠르지만
디스크에서 메모리로 가져오는 데 걸리는 시간을 감안하면
sparse index로 인덱스 크기를 가능한 작게 유지하는 것이 효율적.

---
- 클러스터링 인덱스만이 sparse index를 가질 수 있음. (dense, sparse 둘 다 되지만)
연속적으로 저장되어있기 때문에 대충 하나만 집어도 쉽게 찾아갈 수 있음.
- 그런데 보조 인덱스는 그 속성이 연속적으로 저장되어있지 않기때문에(primary index 순으로 물리적으로 저장되어있으므로)
무조건 dense index로 모두 가리키고 있어야 찾아갈 수 있음. 

#### Dense Index 


#### Sparse Index
희소 인덱스는 인덱스가 순서대로 정렬되어있다는 가정하에 찾아가야 하므로
클러스터링 인덱스에 한해서만 가능하다.

---
#### 다계층 인덱스
블록당 4096 byte (4KB)
하나의 인덱스 엔트리당 40 byte
- 블록 주소 8 byte (64bit 주소체계)
- 블록내 오프셋 8 byte
- 실제 값(검색키 값) 24 byte 정도

**4KB / 40 byte = 블록당 100개의 인덱스 엔트리가 들어감**

1 million 튜플을 가진 릴레이션에 dense index를 구축한다면
최대 1 million개의 인덱스 엔트리가 필요하고

1 million = 100개 x 10,000 블록 = 4KB x 10,000 = 40MB

만약 릴레이션이 100M(1억)개면 
인덱스 엔트리만 4000MB = 4GB 공간을 차지하게 됨.
(대용량의 인덱스가 디스크상에 연속적인 파일로 저장)


#### 인덱스 갱신
삭제 후 삽입.

삽입되는 레코드의 검색 키값을 사용해서 찾기 수행.
- 밀집 인덱스: 
	- 검색 키값이 인덱스에 없다면 시스템은 인덱스의 적당한 위치에 검색 키값을 가지는 인덱스 엔트리를 삽입한다.
	- 그렇지 않다면 1) 


---
# 연습문제

1. 인덱스를 무조건 많이 생성한다고 좋은게 아닌 이유?
- 주요 키(primary key)에 대한 인덱스는 일반적으로 업데이트 시 변경되지 않지만,
 비주요 키에 대한 인덱스는 데이터가 변경될 때마다 업데이트되어야.
- 자주 사용되는 검색 키에만 인덱스를 생성하는 것이 효율성이 떨어지지 않음.

🌠
'index file': search-key와 pointer로 구성되는 레코드들.


