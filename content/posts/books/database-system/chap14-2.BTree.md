+++
categories = ['Database']
series = ['Database-System']
tags = ['λ°μ΄ν„°λ² μ΄μ¤']
title = "BνΈλ¦¬"
date = 2024-05-09T22:50:44+09:00
draft = true
+++
## B+νΈλ¦¬ 
κ³µλ¶€ λ°©λ²•
- μ‚½μ…/μ‚­μ λ” κ·μΉ™ λ”± μ μ–΄λ†“κ³  (λ…Έλ“κ°μ- λ¦¬ν”„ ~n-1 vs nonleaf ~n λ“±)
μ§μ ‘ μΉ΄λ“λ¥Ό μ®κ²¨κ°€λ©΄μ„ + μλ„μ½”λ“λ¥Ό μ΄ν•΄ν•λ‹¤.
- μ§€κΈμ€ μΌλ‹¨ κ°λ…μ΄ μ°μ„ μ΄λΌμ„. BνΈλ¦¬ ν™•μ¥λ¶€ν„°?

### B+νΈλ¦¬ μΈλ±μ¤ νμΌ
μΈλ±μ¤ μμ°¨νμΌμ μ£Όμ” λ‹¨μ : νμΌμ΄ μ»¤μ§μλ΅ μΈλ±μ¤λ¥Ό μ°Ύμ•„μ„ κ·Έ λ°μ΄ν„°λ¥Ό μ—°μ†μΌλ΅ μ¤μΊ”ν•λ” μ„±λ¥μ΄ κ°μ†ν•λ” κ²ƒ.
B+νΈλ¦¬ μΈλ±μ¤ κµ¬μ΅°λ” μ‚½μ…/μ‚­μ μ—λ„ μ„±λ¥μ„ μ μ§€ν•λ‹¤.
νΈλ¦¬ λ£¨νΈμ—μ„ leafκΉμ§€ λ¨λ“  κ²½λ΅μ κΈΈμ΄κ°€ κ°™μ€ balanced tree.
treeμ—μ„ non-leafλ…Έλ“λ” |n/2|(μ¬λ¦Ό)μ™€ n μ‚¬μ΄μ μμ‹μ„ κ°–κ³  μκ³ 
λ£¨νΈλ” 2~nκ° μ‚¬μ΄μ μμ‹μ„ κ°–λ”λ‹¤.

#### B+νΈλ¦¬μ κµ¬μ΅°
λ‹¤κ³„μΈµ μΈλ±μ¤μ΄μ§€λ§ λ‹¤κ³„μΈµ μΈλ±μ¤ μμ°¨νμΌκ³Όλ” λ‹¤λ¦„.
κ³ μ ν‚¤λ¥Ό κ°€μ •.

π”Ή Leaf Node
n-1κ°μ κ²€μƒ‰ ν‚¤κ°’κ³Ό nκ°μ ν¬μΈν„°.
κ²€μƒ‰ν‚¤κ°’μ€ μ •λ ¬λ μμ„.
Pointerλ” μµμΆ… rowλ¥Ό κ°€λ¦¬ν‚΄.

π”Ή NonLeaf Node
λ‹¤κ³„μΈµ Sparse Indexλ¥Ό ν•μ„±. 
all pointers are pointers to tree nodes λΌλ” μ μ΄ λ¦¬ν”„λ…Έλ“μ™€ μ°¨μ΄μ .
- P1μ΄ κ°€λ¦¬ν‚¤λ” λ¨λ“  κ²€μƒ‰ν‚¤λ” K1λ³΄λ‹¤ μ‘λ‹¤.
- Piκ°€ κ°€λ¦¬ν‚¤λ” κ²€μƒ‰ν‚¤λ” Ki-1λ³΄λ‹¤ κ°™κ±°λ‚ ν¬λ‹¤
Ki-1 <= Pi < Ki

#### B+νΈλ¦¬ μΏΌλ¦¬
μλ„ μ½”λ“
- λ£¨νΈλ…Έλ“μ—μ„ μ‹μ‘ν•΄ μΌλ¶€ λ¦¬ν”„λ…Έλ“κΉμ§€ νΈλ¦¬ κ²½λ΅ νƒμƒ‰
- μ‹¤μ  κµ¬ν„μ€ iterator. nextλ¥Ό ν†µν•΄ μ—°μ†μ μΈ λ μ½”λ“λ¥Ό κ°€μ Έμ΄. μ—”νΈλ¦¬λ¥Ό ν•λ‚μ”© κ²€μ‚¬ν•λ” κ±΄ λ‘κ°™μ€λ“―.

#### B+ μΏΌλ¦¬ λΉ„μ©
- ν• λ…Έλ“λ” λ³΄ν†µ disk block μ‚¬μ΄μ¦μ™€ κ°™μ.(4KB)
- n μ€ λ€λµ 100κ° (40 bytes per index entry) >> λ…Έλ“λ‹Ή 100κ° μΈλ±μ¤ μ—”νΈλ¦¬ μ €μ¥. μ‹¤μ  λ μ½”λ“ rowκ°€ μ•„λ‹λΌ μ—”νΈλ¦¬(μ£Όμ†, μ¤ν”„μ…‹, κ²€μƒ‰ν‚¤κ°’μ„ ν¬ν•¨)
- 1 million search key values and n = 100
	- at most log50(1M) = 4 λ…Έλ“λ§ κ±°μΉλ©΄ μ°Ύμ„ μ μμ.
		- μ—¬κΈ°μ„ n/2 = 50 -> ν• λ…Έλ“κ°€ μµμ† 50κ°~100κ° μ—”νΈλ¦¬.
	- λ°λ©΄ binary treeλ” 2^20μ€ ν•΄μ•Ό 1Mμ„. vs 50^3~4 = 1M
- μ΄λ¬ν• μ°¨μ΄λ”(λ…Έλ“κ°μ?) μ‹¤λ΅ μ—„μ²­λ‚λ‹¤. μ™λƒν•λ©΄ λ¨λ“  λ…Έλ“ μ•΅μ„Έμ¤λ” disk I/Oλ¥Ό μ”ν•λ©° 20ms μ •λ„μ μ‹κ°„μ΄ λ“¤κΈ° λ•λ¬Έμ΄λ‹¤..

```
nμ€ ν• λ…Έλ“κ°€ κ°€μ§ μ μλ” μµλ€ μμ‹ λ…Έλ“ μ λλ” μµλ€ κ°’μ μλ¥Ό μλ―Έν•©λ‹λ‹¤. μ „μ²΄ λ μ½”λ“ κ°μκ°€ μ•„λ‹™λ‹λ‹¤.
 B+ νΈλ¦¬μ νΉμ„±μ— λ”°λ¥΄λ©΄:
 β€Άλ£¨νΈ λ…Έλ“λ‚ λ¦¬ν”„ λ…Έλ“κ°€ μ•„λ‹ λ…Έλ“λ” n/2κ°μ—μ„ nκ° μ‚¬μ΄μ μμ‹ λ…Έλ“λ¥Ό κ°€μ§‘λ‹λ‹¤.
 β€Άλ¦¬ν”„ λ…Έλ“λ” (n-1)/2κ°μ—μ„ n-1κ° μ‚¬μ΄μ κ°’μ„ κ°€μ§‘λ‹λ‹¤.
 
μ•μ„ μμ‹μ—μ„ n = 100μ΄μ—λ κ²ƒμ€ ν• λ…Έλ“κ°€ μµλ€ 100κ°μ μ—”νΈλ¦¬(μμ‹ λ…Έλ“ ν¬μΈν„° + κ°’)λ¥Ό κ°€μ§ μ μλ‹¤λ” λ»μ…λ‹λ‹¤. κ·Έλμ„ λ¦¬ν”„ λ…Έλ“λ” μµμ† (100-1)/2 = 49κ°, μµλ€ 99κ°μ κ°’μ„ κ°€μ§€κ² λλ” κ²ƒμ…λ‹λ‹¤.
```

```groovy
function findRange(lb, ub)
/* Return all records with search key value B such that lb <= V <= ub */
	Set resultSet = {};
	Set C = root node
	while (C is not a leaf node) begin
		Let i = smallest number such that lb <= C.Ki
		if there is no such number i then begin
			Let Pm = last non-null pointer in the node
			Set C = C.Pm
		end
		else if (lb = C.Ki) then Set C = C.Pi+1
		else Set C = C.Pi   // lb < C.Ki
	/* C is leaf node */
	Let i be the least value such that Ki >= lb
	if there is no such i
		then Set i = 1 + number of keys in C; // λ‹¤μ λ¦¬ν”„λ΅ μ΄λ™
	Set done = false;
	while (not done) begin
		Let n = number of keys in C
		if (i <= n and C.Ki <= ub) then begin  // ν•΄λ‹Ή λ…Έλ“ μ•μ—μ„μ i = 1~n ?
			Add C.Pi to resultSet
			Set i = i + 1 // λ°λ³µλ¬Έ
		end
		else if (i <= n and C.Ki > ub) 
			then Set done = true; // while μΆ…λ£
		else if (i > n and C.Pn+1 is not null)
			then Set C = C.Pn+1, and i = 1 // λ‹¤μ λ¦¬ν”„λ…Έλ“κΉμ§€ μ‚΄ν΄λ΄μ•Ό ν•¨.
		else Set done = true;  // no more leaves to the right
	end
	return resultSet;
```

### Non-Unique Keys
λ³µν•© μΈλ±μ¤λ¥Ό μƒμ„±.
name, IDλ¥Ό μƒκ°.
kim, yoon λ“±μ€ λΉ„κ³ μ  ν‚¤μ΄λ―€λ΅ IDλ¥Ό λ¶™μ—¬μ„ μΈλ±μ¤λ¥Ό μƒμ„±ν•λ”λ°.
kimμ„ κ°€μ§„ λ¨λ“  νν”μ„ κ²€μƒ‰ν•λ ¤λ©΄,
findRange(lb, ub)
- lb = (kim, -INF)
- ub = (kim, +INF)

ν‚¤ λΉ„κµ μ—°μ‚°
- λ‹¨μΌ ν‚¤: lb <= C.Kiμ™€ C.Ki <= ub λΉ„κµ
- λ³µν•© ν‚¤: (kim, -β) <= C.Kiμ™€ C.Ki <= (kim, +β) λΉ„κµ

μ„ λ°©μ‹μ— λ€ν• λ€μ•?
- buckets on seperate block (λ³„λ΅.)
	- μ¥μ : κ²€μƒ‰ ν‚¤μ— λ€ν• λ¨λ“  λ μ½”λ“λ¥Ό ν• λ²μ— κ°€μ Έμ¬ μ
	- λ‹¨μ : "λ³„λ„μ λΈ”λ΅"μ— μ €μ¥λ λ²„μΌ“μ—μ„ λ μ½”λ“λ¥Ό κ°€μ Έμ¤λ” λ° μ¶”κ°€μ μΈ I/O μ‘μ—…μ΄ ν•„μ”
```c
λ°μ΄ν„°: [(kim, 1), (kim, 2), (lee, 1), (park, 1), (kim, 3)]
λ²„μΌ“ κµ¬μ΅°: kimμ΄λΌλ” ν‚¤λ¥Ό κ°€μ§„ λ μ½”λ“λ“¤μ„ ν•λ‚μ λ²„μΌ“μ— λ¨μ€λ‹¤.

κ²€μƒ‰ν‚¤: "kim"
λ²„μΌ“: [ (kim, 1), (kim, 2), (kim, 3) ]
```
- κ° ν‚¤μ— νν” ν¬μΈν„° λ¦¬μ¤νΈλ¥Ό μ‚¬μ©
	- κ° κ²€μƒ‰ ν‚¤μ— λ€ν•΄ ν•΄λ‹Ή ν‚¤λ¥Ό κ°€μ§„ λ μ½”λ“λ“¤μ ν¬μΈν„° λ¦¬μ¤νΈλ¥Ό μ μ§€
	- μ¥μ : κ³µκ°„ μ¤λ²„ν—¤λ“κ°€ μ κ³ , κ²€μƒ‰ μ‹ μ¶”κ°€ λΉ„μ©μ΄ λ“¤μ§€ μ•μ
	- λ‹¨μ : κΈ΄ λ¦¬μ¤νΈλ¥Ό μ²λ¦¬ν•λ” μ¶”κ°€ μ½”λ“κ°€ ν•„μ”. μ‚­μ  μ‘μ—… μ‹ λ¦¬μ¤νΈμ—μ„ ν¬μΈν„°λ¥Ό μ κ±°ν•λ” κ²ƒμ΄ λ³µμ΅ν•  μ.
```c
κ²€μƒ‰ ν‚¤: "kim"
// kim"μ΄λΌλ” ν‚¤λ¥Ό κ°€μ§„ λ μ½”λ“λ“¤μ ν¬μΈν„° λ¦¬μ¤νΈλ¥Ό μ μ§€
ν¬μΈν„° λ¦¬μ¤νΈ: [ pointer to (kim, 1), pointer to (kim, 2), pointer to (kim, 3) ]
```

- λ μ½”λ“ μ‹λ³„μλ¥Ό μ¶”κ°€ν•΄ κ²€μƒ‰ν‚¤λ¥Ό κ³ μ ν•κ² λ§λ“¤κΈ°
```c
κ²€μƒ‰ ν‚¤: (kim, 1), (kim, 2), (kim, 3)
```
\
 
### Update om B+Trees: Insertion
pr: pointer to record
v: search key value of the record

find the leaf node in which search key value would apear.
- if there is room in leaf node, insert (v, pr) pair
- otherwise, split the node (along with new (v,pr) entry), and propagate update to parent nodes.

λ…Έλ“ λ¶„ν• 
- take  the n(search key value, ptr) pairs(μ‚½μ…ν•  μ—”νΈλ¦¬ ν¬ν•¨) in sorted order.
- μ²« |n/2| μ¤λ¦¬μ§€λ„ λ…Έλ“λ¥Ό μ•μ— λ‘κ³  λ‚λ¨Έμ§€λ” new nodeμ—. 
- new nodeκ°€ p, pμ—μ„ κ°€μ¥ μ‘μ€ ν‚¤κ°’μ„ kλΌκ³  ν•μ. 
	- (k,p)λ¥Ό λ¶€λ¨ λ…Έλ“λ΅ μ¬λ¦¬λ”λ°, not full λ¶€λ¨λ…Έλ“κ°€ λ‚μ¬λ•κΉμ§€.
	- μµμ•…μ κ²½μ° λ£¨νΈλ…Έλ“κ°€ λ°μΌλ΅ μΌκ°μ§€κ³  μ° λ£¨νΈκ°€ ν•λ‚ λ” μƒκ²¨μ„ height += 1μ΄ λλ‹¤.
