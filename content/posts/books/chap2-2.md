+++
series = ['컴퓨터 밑바닥의 비밀']
tags = ['프로세서', '스레드', 'CS']
title = '컴퓨터 밑바닥의 비밀 - 2장-2)콜백/비동기/논블로킹에 대해'
date = 2024-04-12T00:20:22+09:00
# draft = true
+++
## 2장. 프로그램을 실행하면 무슨 일이 일어날까?

### 2.5 콜백 함수
#### 콜백이 필요한 이유
주체에 따라 다르게 작동하는 함수 -> 주체가 수백 수천개라면? if else 만으로는 대응할 수 없음.
대신 다르게 작동할 함수를 파라미터로 넣는다면? 
`make_donut(func f)` 함수 하나로 수백 수천개의 작동방식을 축약할 수 있음.

```
void formed_C() {
	// ... C팀에 자체적인 도넛 형성 함수가 있음
}

make_donut(formed_C);  // 콜백함수
```
#### 비동기 콜백
하나의 함수가 완료될 때까지 다음의 중요한 함수가 실행되지 못하는 상황을 개선하기 위해 
함수 내부에서 스레드를 생성하고 그 스레드가 실제 일을 수행하도록 할 수.
아래 예시에서 make_donut을 호출하면 새로운 스레드 t를 생성한 후 즉시 반환되고, important()를 실행할 수 있음
-> 호출자와 피호출자가 각자 스레드에서 병렬로 실행
이처럼 **호출 스레드가 콜백함수 실행 완료여부에 의존하지 않는 것을 '비동기 콜백(asynchronous callback)' 이라 함**
```
void real_make_donut(func f) {   // 함수를 매개변수로 받아 실행
	f();
}

void make_donut(func f) {
	thread t(real_make_donut, f);  // 스레드가 실행할 함수와 매개변수
}
```
콜백 함수의 본질:
한 모듈은 어떤 일을 해야하는 건 알지만, 언제 하게 될지 정확히 알 수 없을 때.
반면 다른 모듈은 언제 해야할지는 알지만 무엇을 해야할지 모르기 때문에
우리가 알고 있는 정보를 콜백 함수에 잘 담아 다른 모듈에 전달해야 함

#### 콜백 함수의 정의
콜백 함수는 다른 코드에 매개변수로 전달되는 실행 가능한 코드.
서드파티 라이브러리에 콜백함수를 지정하는 이유: 서드파티 라이브러리 작성자는 특정 시기에 어떤 작업을 수행해야하는지 알 수 없기 때문.
```javascript
const fs = require('fs');

// 파일 읽기 작업이 완료되면, readFile 함수는 콜백 함수를 호출(첫번째 인자 err는 에러객체, data는 파일의 내용)
// 사실상 thread t(readFile, callback)과 다름없음.
fs.readFile('example.txt', 'utf8', function(err, data) {
    if (err) {
        console.error("Error reading file:", err);
        return;
    }
    // 파일에서 읽은 데이터를 출력
    console.log("File contents:", data);
});
```
**이벤트 핸들러로서의 콜백함수**
우리는 콜백 함수를 작성할 뿐, 직접 호출하지는 않음.
콜백 함수가 호출되는 시점은 '이벤트'가 발생하면 이를 처리할 수 있는 코드를 호출할 때.
-> event-driven programming에 적합

#### 두 가지 콜백 유형
- 동기 콜백: 함수 A 호출 + 콜백 함수를 매개변수로 전달할 때, 콜백 함수를 실행하고 나서 A가 반환
- 비동기 콜백: 콜백 함수와 주 프로그램이 동시에 실행. 서로 다른 스레드/프로세스에서 실행. 
	- 비동기 콜백은 콜백 함수가 진행되는 동안 주 프로그램이 다른 일을 할 수 있음 

#### 비동기 콜백의 문제: Callback hell
예를 들어 각 서비스가 앞서 호출한 서비스의 결과를 사용하여 처리하는 경우
```
a = GetServiceA()
b = GetServiceB(a)
c = GetServiceC(b)
```
```
GetServiceA(() => {
	GetServiceB(a, function(b) {
		GetServiceC(b, function(c) {
			// ...
		})		
	})
})
```

---
### 2.6 동기와 비동기의 이해
#### 동기 호출
```
funcA() {
	readfile(file, buf); // 파일 읽기가 완료될 때까지 실행흐름 일시 중지
}
```
**블로킹 I/O**
최하단 계층은 system call로 운영체제에 요청을 보내고
운영체제는 파일 읽기 작업을 위해 호출 스레드를 일시 중지시키며
커널이 디스크를 읽어오면 스레드가 다시 깨어남.
이때 호출자와 수신자는 같은 스레드일 수 있지만 서로 다른 스레드여도 상관없음.

#### 비동기 호출
비동기 호출에서는 작업이 완료되었는지 언제 알 수 있을까?
```
void handler(void* buf) {
	// 파일 내용 처리
}
read(buf, handler) // 파일 내용을 처리할 함수를 매개변수로 전달
``` 
이때 수신자는 호출자와 다른 스레드에서 처리하며,
작업이 완료되면 호출자에게 notification 신호나 메시지를 보냄.

#### 웹 서버에서 동기/비동기 작업
```
A;
B;
데이터베이스 요청;  // 유일한 I/O 작업
C;
D;
```
이러한 웹서버에는 메인 스레드와 데이터베이스 처리를 하는 스레드 두 개가 있음.

1. 동기 작업
```
main thread() {
	while (1) {
		요청 수신;
		A;
		B;
		데이터베이스 요청, 결과가 반환될 때까지 대기;
		C;
		D;
		결과 반환;
	}
}

database_thread() {
	while (1) {
		요청 수신;
		데이터베이스 처리;
		결과 반환;
	}
}
```
2. 비동기 작업
##### 1) 메인 스레드가 데이터베이스 처리결과를 전혀 신경쓰지 않을 때
콜백함수로 C,D의 단계에 대한 작업 방법을 데이터베이스 스레드에 넘겨줌
```
void handle_CD_after_DB_query() {
	C;
	D;
}
// 메인 스레드가 데이터베이스 처리 요청시
DB_query(request, handle_CD_after_DB_query);
```
데이터베이스 스레드는 request를 처리한 후 handle_CD 함수를 호출하면 됨. 
이 함수를 데이터베이스에 정의하고 직접 호출하는 대신 콜백 함수를 통해 전달받아 실행하는 것. 

*데이터베이스 스레드 입장에서는 자신의 주 업무인 request만 처리하고 나서 콜백 함수를 호출하기만 할 뿐
이 콜백 함수의 내용에는 관심이 없고, 관심을 가져서도 안됨.*


##### 2) 메인 스레드가 데이터베이스 작업 결과를 신경쓰는 상황
데이터베이스 스레드는 알림 방식으로 작업 결과를 주 스레드로 전송해야 함.
주 스레드는 요청 후반부(C, D)를 계속 처리.
동기 호출과 달리 데이터베이스 처리 와중에도 메인 스레드는 다른 일을 할 수 있음.


---
### 2.7 블로킹과 논블로킹
#### 블로킹의 핵심 문제는 입출력
두 가지 대상. 서로 상호작용하는 모듈 또는 함수, 두 통신 당사자.
함수의 호출로 인해 호출자의 스레드가 OS에 의해 일시 중지되는 경우는 주로 입출력 작업.
호출 스레드의 일시중지 없이 입출력 작업을 하려면 논블로킹 호출을 사용

#### 논블로킹과 비동기 입출력
논블로킹 함수를 호출하면 OS는 스레드를 일시중지시키지 않고 함수를 즉시 반환.
두 가지 작업은 병행 처리됨.
데이터를 언제 수신했는지 알 수 있는 방법은
- 스레드 메시지
- 데이터 수신 처리를 담당하는 함수를 콜백으로 전달

논블로킹 상황에서 작업이 완성되었는지 확인하는 것은
1) 인내심이 강한 경우와 
2) 부족한 경우(인터벌로 계속 확인, 그러나 리소스를 소모)로 나뉨

1. 인내심이 강한 경우
- **네트워크 데이터를 처리하는 handler 함수를 콜백으로 전달하는 논블로킹 함수**: 
```c
void handler (void *buf) {
	// 수신된 네트워크 데이터 처리
}
while (true) {
	fd = accept();
	recv(fd, buf, NON_BLOCKING_FLAG, handler); // 호출 즉시 반환, 논블로킹
}
```
2. 인내심이 부족한 경우
네트워크 데이터의 도착을 감지하는 전용 함수 check.
- **recv 함수 자체는 논블로킹이지만, 결론적으로는 동기 호출.** 
```c
while (true) {
	fd = accept();
	recv(fd, buf, NON_BLOCKING_FLAG); // 논블로킹	

	while (!check(fd)) {
		// 순환 감지. 데이터가 도착하기 전까지는 hanlder 함수를 사용할 수 없게 함
		// 그러나 반복문에서 CPU 리소스가 쓸데없이 소모되므로 매우 비효율적
	}
	handler(buf);
}
```
이처럼 논블로킹이더라도 전체적으로 반드시 비동기라는 것은 아니며, 어떤 제어 장치를 사용했느냐에 따라 달라짐.

이처럼 고성능 서버를 구현하기 위해 
프로세스/스레드/고루틴 + 동기/비동기, 블로킹/논블로킹 을 활용.

(참고)
Node.js 환경에서는 기본적으로 논블로킹 I/O 모델을 사용.
파일 시스템 작업을 수행할 때 비동기 함수를 사용하여 콜백, 프로미스, 또는 async/await를 통해 논블로킹 방식으로 처리.
여기서 async/await는 비동기 호출을 제어하기 위해 쓴다고 볼 수.
```javascript
const fs = require('fs');

// Read file asynchronously
fs.readFile('/path/to/file.txt', 'utf8', (err, data) => {
    if (err) {
        console.error("An error occurred:", err);
        return;
    }
    console.log("File content:", data);
});

console.log("This will run before the file is read because readFile is non-blocking.");
```

---
### 2.8 높은 동시성과 고성능을 갖춘 서버를 구현하려면
#### Concurrent Programming
1. 멀티 프로세스
- 리눅스에서는 fork로 여러 자식 프로세스. 생성과 종료에 드는 부담은 있음
2. 멀티 스레드
- 프로세스 주소공간을 공유하므로 스레드간 통신을 위한 별도의 통신작동 방식이 필요없음
- 단점은 하나의 스레드가 강제종료되면 프로세스를 공유하던 모든 스레드가 같이 강제종료된다는 점.
3. 이벤트 기반 프로그래밍

#### 이벤트 순환과 이벤트 구동
이벤트: 대부분 입출련 관련. 네트워크 수신여부, 파일 읽기/쓰기 가능여부 등
이벤트 처리 함수: event handler

이벤트가 도착할 때까지 기다렸다가, 이벤트 유형을 확인.
이어서 해당 유형의 이벤트 핸들러를 찾아 호출함
- 서버에서 이벤트는 사용자 요청에 해당. 
- **이벤트 순환(event loop): 계속 들어오는 사용자 요청 이벤트를 while, for문으로 반복적으로 처리**

```c
while (true) {
	event = getEvent(); // 이벤트 수신 대기
	handler(event); // 이벤트 처리
}
```
여기서 해결해야 할 문제
1. 이벤트 소스 문제: 하나의 함수로 여러 이벤트를 가져오려면?
2. 이벤트 루프와 핸들러 함수가 다른 스레드에서 실행되려면?

#### Input/Output Multiplexing
#### 1. 이벤트 소스와 입출력 다중화

프로그램은 모두 file descriptor를 사용하여 입출력 작업을 함.
동시에 fd 여러개를 처리하려면?

ex) 사용자 연결이 10개, 이에 대응하는 fd가 10개인 서버가 데이터를 수신하려고 대기 중인 경우
fd 10개를 순차적으로 처리하기보다는, 
fd 10개를 감시하고 있다가 하나라도 데이터가 들어오면 알려달라고 OS에 작동방식을 요청.

#### epoll
```c
epoll_fd = epoll_create();
// fd를 epoll이 처리하도록 지정
Epoll_ctl(epoll_fd, fd1, fd2, fd3, ...);

while (1) {
	int n = epoll_wait(epoll_fd);

	for (i = 0; i < n; i++) {
		// 특정 이벤트 처리
	}
}
```
epoll은 이벤트 순환을 위해 탄생. 
epoll_wait()는 이벤트를 기다리는 함수로, 입출력 다중화 기술이 지속적으로 다양한 이벤트를 제공. 

#### 2. 이벤트 루프와 다중 스레드
입출력 작업이 있거나
각 처리함수가 CPU 자원을 점유하는 시간이 길다면
컴퓨터 다중 코어를 활용해멀티 스레드에서 돌리면 됨. 
-> event loop 스레드 하나와 worker thread 4개
worker thread를 thread pool로 관리할 수도 있음

#### 이벤트 순환과 입출력
1. 입출력 작업에 논블로킹 인터페이스가 있는 경우
- 인터페이스가 즉시 반환되므로 이벤트 루프에서 직접 호출 가능
2. **이벤트 루프 내에서 절대 블로킹은 호출하면 안됨**
- 그렇지 않으면 이벤트 루프 스레드가 일시 중지되므로 전체 시스템이 앞으로 나아갈 수 없음. 
따라서 **블로킹 입출력 호출이 포함된 작업은 worker thread에 전달해야 함.**

이제 worker thread의 handler 함수를 다뤄보자.

#### 비동기와 콜백 함수
handler 함수 기능은 데이터베이스 처리 후 반환처럼 간단할 수도 있지만 점점 복잡해짐.
여러 서버가 조합되어 하나의 사용자 요청을 처리.

서버는 RPC(remote procedure call)를 통해 통신. 
```c
GetUserInfo(request, response);
```
이 함수의 최하위 계층에서는 네트워크 통신을 수행. 
대상 서버에 요청을 보내고 응답을 받아 response에 저장 후 반환.
이 서버에 대응하는 핸들러 함수는:
```c
void handler(request) {
	A;
	B;
	GetUserInfo(request, response); // 서버 A에 요청
	C;
	GetQueryInfo(request, response); // 서버 B
	D;
	GetStockInfo(request, response); // 서버 C
}
```
이 경우 RPC 호출이 모두 블로킹이라 서버가 응답하기 전까지는 함수가 반환되지 않음. -> 스레드가 빈번하게 중단됨..
따라서 더 나은 접근 방식은 RPC 호출을 비동기로 하는 것.
```c
GetUserInfo(request, callback);
```
비동기 호출은 호출 스레드를 블로킹하지 않기 때문에 함수가 즉시 반환되며,
다만 응답에 대한 결과가 없기 때문에 
GetUserInfo() 호출 후 처리할 내용을 콜백에 담아 RPC를 호출해야. 
```c
handler_after_GetUserInfo(response) {
	C;
	GetQueryInfo(request, handler_after_GetQueryInfo); // 서버 B에 요청
}

void handler(request) {
	A;
	B;
	GetUserInfo(request, handler_after_GetUserInfo); // 서버 A에 요청
}
```
이제 주 프로세스는 네 개로 분할되고, 콜백 안에 콜백이 포함됨.
그러나 서비스가 더 많아지만 이러한 형태로는 관리가 거의 불가능. 

---
#### 코루틴: 동기 방식의 비동기 프로그래밍
handler 함수가 코루틴에서 실행되도록 할 수. 
(위에선 각 핸들러 함수가 각각의 스레드에서 실행됐다면, 코루틴을 사용하면 하나의 스레드에 여러 핸들러 함수를 등록할 수 있음)

**코루틴과 스레드를 사용하는 블로킹 호출**
핸들러 함수는 동기로 작성되지만, yield로 CPU 제어권을 반환하는 형태로 바로 다음 함수를 호출하므로
결과적으로 비동기 실행과 같은 효과를 얻을 수 있음. 
-> 코루틴이 일시 중지되어도 worker thread는 블로킹되지 않음. 


---
### 2.9 컴퓨터 시스템: 데이터, 코드, 콜백, 클로저, 컨테이너, 가상머신

#### 코드, 데이터, 변수, 포인터
별칭으로 명령어 여러개를 지칭하는 함수라는 것을 발명.
별칭을 사용하여 데이터를 지칭할 수 있으며
포인터 또는 참조의 경우 동일한 데이터를 여러 변수를 사용하여 참조할 수 있음.

#### 콜백 함수와 클로저
변수 여러개가 동일한 코드를 참조하는 것도 가능. 
일급 객체 함수(first-class function)은 함수를 일반 변수를 다루듯 매개변수로 전달할 수 있음.
-> 콜백함수

콜백함수가 호출함수의 변수에 접근할 필요가 있을 때는 '클로저'를 사용
클로저는 콜백함수를 일부 데이터와 한데 묶어 변수로 취급하는 것을 의미.

#### 컨테이너와 가상머신 기술
프로그램과 프로그램이 의존하는 실행환경을 묶어 컨테이너를 구성.
컨테이너는 운영체제를 가상화. 
OS 기능을 이용해 프로세스를 격리하고 CPU/메모리/디스크 접근을 제어하여 
컨테이너에 포함된 프로세스가 OS내 자신의 프로세스만 존재하는 것처럼 간주.



