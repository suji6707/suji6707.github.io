+++
series = ['컴퓨터 밑바닥의 비밀']
tags = ['프로세서', '스레드', 'CS']
title = '컴퓨터 밑바닥의 비밀 - 2장-2)콜백/비동기/논블로킹에 대해'
date = 2024-04-12T00:20:22+09:00
draft = true
+++
## 2장. 프로그램을 실행하면 무슨 일이 일어날까?

### 2.5 콜백 함수
#### 콜백이 필요한 이유
주체에 따라 다르게 작동하는 함수 -> 주체가 수백 수천개라면? if else 만으로는 대응할 수 없음.
대신 다르게 작동할 함수를 파라미터로 넣는다면? 
`make_donut(func f)` 함수 하나로 수백 수천개의 작동방식을 축약할 수 있음.

```c
void formed_C() {
	// ... C팀에 자체적인 도넛 형성 함수가 있음
}

make_donut(formed_C);  // 콜백함수
```
#### 비동기 콜백
하나의 함수가 완료될 때까지 다음의 중요한 함수가 실행되지 못하는 상황을 개선하기 위해 
함수 내부에서 스레드를 생성하고 그 스레드가 실제 일을 수행하도록 할 수.
아래 예시에서 make_donut을 호출하면 새로운 스레드 t를 생성한 후 즉시 반환되고, important()를 실행할 수 있음
-> 호출자와 피호출자가 각자 스레드에서 병렬로 실행
이처럼 **호출 스레드가 콜백함수 실행 완료여부에 의존하지 않는 것을 '비동기 콜백(asynchronous callback)' 이라 함**
```c
void real_make_donut(func f) {   // 함수를 매개변수로 받아 실행
	f();
}

void make_donut(func f) {
	thread t(real_make_donut, f);  // 스레드가 실행할 함수와 매개변수
}
```
콜백 함수의 본질:
한 모듈은 어떤 일을 해야하는 건 알지만, 언제 하게 될지 정확히 알 수 없을 때.
반면 다른 모듈은 언제 해야할지는 알지만 무엇을 해야할지 모르기 때문에
우리가 알고 있는 정보를 콜백 함수에 잘 담아 다른 모듈에 전달해야 함

#### 콜백 함수의 정의
콜백 함수는 다른 코드에 매개변수로 전달되는 실행 가능한 코드.
서드파티 라이브러리에 콜백함수를 지정하는 이유: 서드파티 라이브러리 작성자는 특정 시기에 어떤 작업을 수행해야하는지 알 수 없기 때문.
```javascript
const fs = require('fs');

// 파일 읽기 작업이 완료되면, readFile 함수는 콜백 함수를 호출(첫번째 인자 err는 에러객체, data는 파일의 내용)
// 사실상 thread t(readFile, callback)과 다름없음.
fs.readFile('example.txt', 'utf8', function(err, data) {
    if (err) {
        console.error("Error reading file:", err);
        return;
    }
    // 파일에서 읽은 데이터를 출력
    console.log("File contents:", data);
});
```
**이벤트 핸들러로서의 콜백함수**
우리는 콜백 함수를 작성할 뿐, 직접 호출하지는 않음.
콜백 함수가 호출되는 시점은 '이벤트'가 발생하면 이를 처리할 수 있는 코드를 호출할 때.
-> event-driven programming에 적합

#### 두 가지 콜백 유형
- 동기 콜백: 함수 A 호출 + 콜백 함수를 매개변수로 전달할 때, 콜백 함수를 실행하고 나서 A가 반환
- 비동기 콜백: 콜백 함수와 주 프로그램이 동시에 실행. 서로 다른 스레드/프로세스에서 실행. 
	- 비동기 콜백은 콜백 함수가 진행되는 동안 주 프로그램이 다른 일을 할 수 있음 

#### 비동기 콜백의 문제: Callback hell
예를 들어 각 서비스가 앞서 호출한 서비스의 결과를 사용하여 처리하는 경우
```c
a = GetServiceA()
b = GetServiceB(a)
c = GetServiceC(b)
```
```c
GetServiceA(() => {
	GetServiceB(a, function(b) {
		GetServiceC(b, function(c) {
			// ...
		})		
	})
})
```

---
### 2.6 동기와 비동기의 이해
#### 동기 호출
```c
funcA() {
	readfile(file, buf); // 파일 읽기가 완료될 때까지 실행흐름 일시 중지
}
```
**블로킹 I/O**
최하단 계층은 system call로 운영체제에 요청을 보내고
운영체제는 파일 읽기 작업을 위해 호출 스레드를 일시 중지시키며
커널이 디스크를 읽어오면 스레드가 다시 깨어남.
이때 호출자와 수신자는 같은 스레드일 수 있지만 서로 다른 스레드여도 상관없음.

#### 비동기 호출
비동기 호출에서는 작업이 완료되었는지 언제 알 수 있을까?
```c
void handler(void* buf) {
	// 파일 내용 처리
}
read(buf, handler) // 파일 내용을 처리할 함수를 매개변수로 전달
``` 
이때 수신자는 호출자와 다른 스레드에서 처리하며,
작업이 완료되면 호출자에게 notification 신호나 메시지를 보냄.

#### 웹 서버에서 동기/비동기 작업
```c
A;
B;
데이터베이스 요청;  // 유일한 I/O 작업
C;
D;
```
이러한 웹서버에는 메인 스레드와 데이터베이스 처리를 하는 스레드 두 개가 있음.

1. 동기 작업
```c
main thread() {
	while (1) {
		요청 수신;
		A;
		B;
		데이터베이스 요청, 결과가 반환될 때까지 대기;
		C;
		D;
		결과 반환;
	}
}

database_thread() {
	while (1) {
		요청 수신;
		데이터베이스 처리;
		결과 반환;
	}
}
```
2. 비동기 작업
##### 1) 메인 스레드가 데이터베이스 처리결과를 전혀 신경쓰지 않을 때
콜백함수로 C,D의 단계에 대한 작업 방법을 데이터베이스 스레드에 넘겨줌
```c
void handle_CD_after_DB_query() {
	C;
	D;
}
// 메인 스레드가 데이터베이스 처리 요청시
DB_query(request, handle_CD_after_DB_query);
```
데이터베이스 스레드는 request를 처리한 후 handle_CD 함수를 호출하면 됨. 
이 함수를 데이터베이스에 정의하고 직접 호출하는 대신 콜백 함수를 통해 전달받아 실행하는 것. 

*데이터베이스 스레드 입장에서는 자신의 주 업무인 request만 처리하고 나서 콜백 함수를 호출하기만 할 뿐
이 콜백 함수의 내용에는 관심이 없고, 관심을 가져서도 안됨.*


##### 2) 메인 스레드가 데이터베이스 작업 결과를 신경쓰는 상황
데이터베이스 스레드는 알림 방식으로 작업 결과를 주 스레드로 전송해야 함.
주 스레드는 요청 후반부(C, D)를 계속 처리.
동기 호출과 달리 데이터베이스 처리 와중에도 메인 스레드는 다른 일을 할 수 있음.


---
### 2.7 블로킹과 논블로킹
#### 블로킹의 핵심 문제는 입출력
두 가지 대상. 서로 상호작용하는 모듈 또는 함수, 두 통신 당사자.
함수의 호출로 인해 호출자의 스레드가 OS에 의해 일시 중지되는 경우는 주로 입출력 작업.
호출 스레드의 일시중지 없이 입출력 작업을 하려면 논블로킹 호출을 사용

#### 논블로킹과 비동기 입출력
논블로킹 함수를 호출하면 OS는 스레드를 일시중지시키지 않고 함수를 즉시 반환.
두 가지 작업은 병행 처리됨.
데이터를 언제 수신했는지 알 수 있는 방법은
- 스레드 메시지
- 데이터 수신 처리를 담당하는 함수를 콜백으로 전달

논블로킹 상황에서 작업이 완성되었는지 확인하는 것은
1) 인내심이 강한 경우와 
2) 부족한 경우(인터벌로 계속 확인, 그러나 리소스를 소모)로 나뉨

1. 인내심이 강한 경우
**네트워크 데이터를 처리하는 handler 함수를 콜백으로 전달하는 논블로킹 함수**: 
```c
void handler (void *buf) {
	// 수신된 네트워크 데이터 처리
}
while (true) {
	fd = accept();
	recv(fd, buf, NON_BLOCKING_FLAG, handler); // 호출 즉시 반환, 논블로킹
}
```
2. 인내심이 부족한 경우
네트워크 데이터의 도착을 감지하는 전용 함수 check.
**recv 함수 자체는 논블로킹이지만, 결론적으로는 동기 호출.** 
```c
while (true) {
	fd = accept();
	recv(fd, buf, NON_BLOCKING_FLAG); // 논블로킹	

	while (!check(fd)) {
		// 순환 감지. 데이터가 도착하기 전까지는 hanlder 함수를 사용할 수 없게 함
		// 그러나 반복문에서 CPU 리소스가 쓸데없이 소모되므로 매우 비효율적
	}
	handler(buf);
}
```

(참고)
Node.js 환경에서는 기본적으로 논블로킹 I/O 모델을 사용.
파일 시스템 작업을 수행할 때 비동기 함수를 사용하여 콜백, 프로미스, 또는 async/await를 통해 논블로킹 방식으로 처리.
여기서 async/await는 비동기 호출을 제어하기 위해 쓴다고 볼 수.
```javascript
const fs = require('fs');

// Read file asynchronously
fs.readFile('/path/to/file.txt', 'utf8', (err, data) => {
    if (err) {
        console.error("An error occurred:", err);
        return;
    }
    console.log("File content:", data);
});

console.log("This will run before the file is read because readFile is non-blocking.");
```

---
### 2.8 높은 동시성과 고성능을 갖춘 서버를 구현하려면


---
### 2.9 컴퓨터 시스템: 데이터, 코드, 콜백, 클로저, 컨테이너, 가상머신




