+++
series = ['컴퓨터 밑바닥의 비밀']
tags = ['프로세서', '스레드', 'CS']
title = '컴퓨터 밑바닥의 비밀 - 2장.프로그램을 실행하면 무슨 일이 일어날까'
date = 2024-04-12T00:20:22+09:00
# draft = true
+++
## 2장. 프로그램을 실행하면 무슨 일이 일어날까?

### 2.1 운영체제, 프로세스, 스레드
##### 모든 것은 CPU에서 시작
- CPU가 명령어를 실행하는 과정: 레지스터의 PC(program counter)에서 명령어 주소를 가져와 실행
- 최초의 PC 레지스터 값: 프로그램 시작시 메모리로 로드된 명령어 중 main 함수에서 첫 번째 기계어의 메모리 주소를 PC 레지스터에 기록

##### CPU에서 운영체제까지
- 프로그램을 실행할 때마다 실행 파일을 메모리에 수동으로 복사해야 한다? (X) 
-> 운영체제가 아래 기능들 수행. 
	- 프로그램을 자동으로 적재
		- 프로그램을 적재(load)할 수 있는 메모리 영역을 찾고
		- CPU 레지스터를 초기화하고 함수의 entry point를 찾아 PC 값을 설정
	- 멀티태스킹을 위한 프로세스 관리 도구
- Context: CPU가 어떤 기계어를 실행했는지, 기타 레지스터 값 등 context를 저장해두고 다른 프로세스로 갔다 올 수.
- 프로세스: CPU context를 기록할 수 있는 구조체를 지님. 모든 프로그램은 실행될 때 프로세스 형태로 관리되며, 원하는 대로 일시중지/재시작 가능
- 멀티태스킹: CPU는 한 번에 한 가지 일만 할 수 있지만 컨텍스트 스위칭을 통해 여러 프로그램을 동시에 실행하는 것처럼 보이게 할 수 있음. 

##### 프로세스 주소 공간
- 낮은 주소부터 위로: code, data, heap, stack segment
- 프로세스의 한계: multi-process programming, inter-process communication으로 더 빠르게 처리할 수는 있지만 프로세스 생성시 메모리 부담, 별도 주소공간을 가진 프로세스간 통신이 복잡성을 높임.

##### 프로세스에서 스레드로 진화
- CPU 여러 개가 동일한 프로세스의 기계 명령어를 실행한다면?
	- **CPU의 PC 레지스터에 스레드의 진입 함수 주소를 지정하면 스레드를 실행시킬 수 있음**
	- 스레드는 동일한 프로세스 주소 공간을 공유하므로 더 이상 프로세스간 통신이 필요하지 않음
- 실행시간 단축: 단일 프로세스에서 3분 + 4분 = 7분이 걸릴 일을
스레드 두 개가 CPU 코어 두 개에서 동시에 실행되면 전체 실행 시간은 4분이 됨
- 주소공간 공유: **두 스레드의 작업 결과를 합치는 과정에서 프로세스 간 통신이 필요치 않음**
- 공유 리소스 접근 문제: **CPU가 명령어를 실행할 때 그것이 어떤 스레드에 있는지 인식하지 못하기 때문에**, 다중 스레드가 공유 리소스에 접근할 때 문제가 발생. 이를 muxutal exclution, synchronization을 이용해 명시적으로 직접 해결해야. 

참고) 
node::cluster는 멀티 프로세스
node::worker_thread는 멀티 스레드

##### 다중 스레드와 메모리 구조
- 스택에 저장되는 것: 
	- 함수 실행에 필요한 정보들 - parameter, 지역변수, return address 등이 stack frame에 저장되며, 모든 함수는 실행 시 자신만의 스택 프레임을 가짐. LIFO 순으로 증가/감소. 
- 스레드로 인해 하나의 프로세스내 여러 개의 실행 흐름이 존재하게 되면 스택 영역도 여러개 필요.

##### 스레드 활용 예
- thread-per-request: 요청을 받으면 해당 작업을 처리하는 스레드를 생성하고 작업이 완료되면 스레드를 종료. 긴 작업에서는 적합하나 대량의 짧은 작업에선 리소스 부담, 스레드 전환 간 부담이 증가

##### 스레드 풀
- 스레드를 여러 개 미리 생성해두고, 작업이 생기면 배정. 스레드가 미리 생성되어 있으므로 생성/종료 작업이 빈번하게 발생하지 않음. 핵심은 '스레드의 재사용'.
- DB 쿼리처럼 대량의, 빈번한 짧은 작업들에서 매우 효율적
- 큐 자료구조: 작업을 전달하는 producer와 작업을 처리하는 consumer

---
### 2.2 스레드 간 공유되는 프로세스 리소스
##### 스레드 전용 리소스(thread-private resource)
스레드는 '함수 실행'에 따른 실행 흐름.
- thread context: PC, stack pointer, 함수 실행에 사용되는 레지스터 정보들
- 이러한 private 리소스를 제외한 나머지는 모두 스레드 간에 공유되는 리소스.
- 그러나 스택 영역이 private 하다고 해서 접근 불가능한 것은 아님. 다른 스레드의 스택 프레임에서 포인터를 가져올 수 있다면 그 포인터가 가리키는 데이터에 접근할 수 있다는 의미.
 
##### 스레드 전용 스토리지
- 전역 변수 앞에 `__thread`라는 수식어를 붙이면 컴파일러가 스레드 전용 스토리지에 넣음
- 각 스레드에서 독점적으로 변수를 사용할 수. 하나의 스레드에서 값을 변경해도 다른 스레드에는 반영되지 않음

---
### 2.3 스레드 안전 코드
스레드 공유 리소스: 힙과 데이터 영역
- 이러한 공유 리소스를 사용하는 스레드는 반드시 순서를 따라야 하며,
- lock이나 세마포어 등 장치를 사용

스레드 전용 리소스와 매개변수
- 매개변수가 call by reference인 경우(포인터 전달)나 전역 변수를 가리키면 스레드 안전하지 않게 됨
- 다만 전역 변수의 경우 read only면 스레드 안전
- `__thread`로 스레드 전용 저장소에 배치하면 각 스레드는 자신만의 복사본을 바라보게 되므로 스레드 안전

함수 반환값
- 변수의 주소를 반환하면 잠재적으로 스레드 공유 리소스가 됨.
- 다만 이러한 방법으로 싱글톤 패턴을 구현하는 유용한 경우도 있음

스레드 안전 코드
- 공유 리소스에 접근하는 함수 전후로 `mutex.lock`, `unlock`을 호출하기
- '함수 스코프 안에서' 로컬 변수를 &주소 매개변수로 전달하기

스레드 안전 코드 구현 방법
- 다중 스레드 프로그래밍 환경에서는 어떤 리소스라도 최대한 공유하지 않는 것이 원칙
공유를 해야만 하는 경우엔 아래 장치를 활용
	- thread local storage
	- read-only
	- automic operation (std::atomic)
	- mutual exclusion
- 위에서 언급한 스레드는 커널 스레드(kernel thread)로, 스레드 생성/스케줄링/종료를 모두 운영체제가 수행
- 운영체제에 의존하지 않고 직접 스레드를 구현하려면 더 가벼운 실행 흐름인 '코루틴'을 활용

---