+++
series = ['컴퓨터 밑바닥의 비밀']
tags = ['컴파일', 'CS']
title = '컴퓨터 밑바닥의 비밀 - 1장.프로그래밍 언어부터 프로그램 실행까지'
date = 2024-04-07T00:20:22+09:00
# draft = true
+++
## 프로그래밍 언어를 발명한다면?

## 1장. 프로그래밍 언어부터 프로그램 실행까지

### 1.1 여러분이 프로그래밍 언어를 발명한다면?
    
내가 작성한 코드를 컴퓨터가 어떻게 인식하는가?
    
- 최초의 프로그래머는 CPU와 의사소통
	- punched card로 0과 1로 구성된 명령어를 작성
- 어셈블리어의 등장
	- CPU의 명령어 모음을 기계어에 대응시켜 0과 1 바이너리 대신 add, sub, mov 등 인간이 인식할 수 있는 단어로 프로그램을 만들기 시작
 - 고수준 언어의 등장
 	- if, else, while문과 함수로 반복되는 명령어를 처리하고, 파라미터를 넣어 차이점을 줄 수 있게 됨
- 컴파일러
	- 인간이 작성한 문자열 코드를 트리 형태의 재귀 구문으로 변환함으로써 컴퓨터가 인식할 수 있게 함.
    - 리프 노드를 기계어로 번역하기만 하면 그 결과를 부모 노드에 적용할 수 있고, 루트까지 거슬러 올라가면 전체 트리를 구체적인 기계 명령어로 번역할 수 있음
- 해석형 언어의 탄생
	- 특정 CPU에 구애받지 않고 가상머신 또는 인터프리터를 통해 다양한 환경에서 코드를 실행할 수 있게 됨. 
    - JVM과 같은 가상머신은 자체적인 표준 명령어 집합(byte code)를 사용. 자바를 중간 코드(IR)로 컴파일한 다음 이를 실행 플랫폼의 기계어로 변환하여 실행. 
	- 파이썬과 같은 해석형 언어는 컴파일 없이 각 CPU 플랫폼에 맞는 인터프리터가 있어서 한줄 한줄 읽을 때마다 그에 맞는 기계어 변환이 런타임에 이뤄짐. 마치 각 OS 아키텍처별로 거대한 딕셔너리가 있는 것처럼..

예를 들어 
- C 코드 - 기계어 - CPU
- 자바 코드 - byte code - 기계어 - CPU
- 파이썬 코드 - 인터프리트(해석) - 기계어 - CPU

컴파일 언어와 해석형 언어의 성능차이는 큰 그림에서 최적화를 이루는 것과 한줄 한줄 실행하는 것에서 나오는 듯. 
근데 스크립트 언어라해도 실제 애플리케이션에서는 그보다는 최적화가 잘 됨. JITC(Just in time Compilation) for Javascript가 있고, 크롬 V8은 3개의 JIT 레이어가 있다고 함. 파이썬도 C++ 바인딩 라이브러리 차원에서 컴파일로 성능 최적화 잘 되어있음
    
---
### 1.2 컴파일러는 어떻게 작동하는가?
1. 구문 트리(syntax tree) 생성
컴파일러는 번역기인데, 일종의 텍스트 처리 프로그램(text processor)라고도 볼 수 있음. 
기본적으로 텍스트로 된 소스코드를 토큰으로 잘게 쪼게고 {} 괄호 등을 파싱하는 작업을 통해 구문 트리를 만듦. (중괄호 안에 중괄호.. 이게 일종의 재귀 구문)

2. 의미 분석(semantic analysis)
구문 트리가 생성되고 나면 연산하려는 값들의 타입 등을 체크해서 이상이 없는지 확인. 

3. 중간 코드(Intermediate Representation Code, IR Code) 생성

4. 어셈블리어 코드로 변환
5. 기계어로 변환 - CPU가 실행

---
### 1.3 링커의 비밀
#### 링커의 역할
- 컴파일러가 생성한 대상 파일(object file) 여러 개를 하나로 묶어 하나의 최종 실행파일을 생성
- 종속성이 올바르게 설정되어 있는지, 즉 인터페이스 구현이 종속된 모듈에서 사용 가능한지 확인
- 재배치: 컴파일 시점에서 N으로 표시해둔 부분을 링크 과정에서 정확한 주소를 확인해 N을 실제 메모리 주소로 대체

#### 링커의 심벌 해석
- 링커의 관심 대상은 전역 변수. object file에서 참조하고 있는 각 외부 심벌마다 정의가 하나만, 반드시 존재하는지 확인
- 내가 참조하는 심벌과, 다른 모듈에서 참조하는 나의 심벌 두 가지 정보를 알고있어야 함. 
- 링커가 이것을 알 수 있는 이유는 컴파일러가 만들어둔 심벌 테이블 덕분.
컴파일러는 심벌 테이블을 object file에 저장하며, 링커는 여기서 필요한 정보를 얻어냄.

#### 정적/동적 라이브러리, 실행파일
- 정적 라이브러리: 소스 파일 여러 개를 미리 개별적으로 컴파일하고 링크하여 정적 라이브러리로 생성. 
소스 파일마다 단독으로 컴파일함
- 동적 라이브러리: 참조된 동적 라이브러리 이름, 심벌 테이블, 재배치 정보 등 필수 정보만 실행 파일에 포함됨.
실행 파일에는 컴파일 단계의 필수 정보만 저장되므로 동적 링크 생성은 실제 프로그램 실행 시점까지 미룸. (프로그램이 메모리에 적재될 때)

ex) .so 파일: 공유 라이브러리. 라이브러리가 업데이트 되었다고 해서 이것을 참조하는 수많은 소스코드 파일들이 매번 빌드되지 않아도 되는 동적 라이브러리 형태.

---
### 1.4 컴퓨터 과학에서 추상화가 중요한 이유
- 추상화를 통해 복잡도를 제어할 수 있음. ex) 각 모듈이 내부 구현사항을 API로 추상화하면, 쓰는 사람 입장에선 API만 알면 됨
- 컴퓨터 시스템은 하드웨어 위에서 돌아가며, CPU와 입출력 장치 등을 프로그래머가 직접 신경쓰지 않아도 되도록 소프트웨어로 추상화.
(추상화 ex: 물리 메모리 -> 가상 메모리, 네트워크 프로그래밍 -> 소켓, 실행 환경 -> 컨테이너)
- 프로그래머가 기계어를 몰라도 컴파일러가 대신 텍스트 코드 구문을 분석해 CPU 기계 명령어를 생성해주며, 
링커가 모든 코드와 데이터, 라이브러리를 한데 묶어 실행파일을 생성해줌.