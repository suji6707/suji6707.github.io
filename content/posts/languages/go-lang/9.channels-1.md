+++
title = 'Boot'
date = 2025-01-05T00:20:22+09:00
draft = true
+++
# Channels

* Concurrency
ì–¸ì œ ì¢‹ê³  ì–¸ì œ ë¹„íš¨ìœ¨ì ?

concurrency / parallelism (ë‘˜ì€ ë‹¤ë¥´ì§€ë§Œ ê°™ì€ ë§¥ë½ì—ì„œ ì•„ë˜ì™€ ë¹„êµ)
synchronous / sequential

1 x:=5
2 x++
3 print(x)

CPU í´ëŸ­ ìŠ¤í”¼ë“œì— ë”°ë¼.
instruction /sec
CPUê°€ë¥¼ ë™ì‹œì— ì‹¤í–‰ì‹œí‚¤ë©´ 4ë°° ë” ë¹¨ë¼ì§€ëŠ” ê²ƒ?
ë™ì‹œì— ì‹¤í–‰í•  ìˆ˜ ì—†ëŠ” ê²½ìš°ëŠ” ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¬ ìˆ˜ ì—†ìŒ
-> ê¼­ writing concurrent code ê°€ ë‹µì€ ì•„ë‹ˆë‹¤.

ë©€í‹°ì½”ì–´ pcëŠ” ë™ì‹œì— ì—¬ëŸ¬ ì‘ì—…ì„ ì‹¤í–‰,
ë‹¨ì¼ì½”ì–´ í™˜ê²½ì´ë¼ë©´ í•œ ì½”ì–´ê°€ ì‘ì—…ê°„ ë§¤ìš° ë¹ ë¥´ê²Œ ì „í™˜í•´ ê±°ì˜ ë™ì‹œì— ì‹¤í–‰í•¨.
ì–´ëŠìª½ì´ë“  Goì—ì„œ ë™ì¼í•˜ê²Œ ë³´ì„.

GoëŠ” ë™ì‹œ ì‹¤í–‰ì´ ê°€ëŠ¥í•˜ë„ë¡ ì„¤ê³„ë¨.
go doSomething() 
- goëŠ” ìƒˆë¡œìš´ ê³ ë£¨í‹´ì„ spawní•´ì„œ ë™ì‹œ ì‹¤í–‰

```go
func sendEmail(message string) {
    // ğŸ”´ go ì•ˆì˜ ë‚´ìš©ì€ ê³ ë£¨í‹´ìœ¼ë¡œ ì‹¤í–‰ë˜ë©°, í”„ë¡œê·¸ë¨ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ê³¼ ë™ì‹œì— ì‹¤í–‰ë˜ë„ë¡ í•œë‹¤.
	go func() {
		time.Sleep(time.Millisecond * 250)
		fmt.Printf("Email received: '%s'\n", message)
	}()
	fmt.Printf("Email sent: '%s'\n", message)
}
```

* Channels = ë°ì´í„°ë¥¼ ì „ë‹¬í•˜ëŠ” í
typed, thread-safe queue.
ì„œë¡œë‹¤ë¥¸ ê³ ë£¨í‹´ì´ ìƒí˜¸ì‘ìš©í•˜ê²Œ í•´ì£¼ëŠ”.

ch := make(chan int)
ch <- 69
ì±„ë„ì— ë°ì´í„°ë¥¼ ë³´ëƒ„.
ìˆ˜ì‹ ì¸¡ì—ì„œ ë°ì´í„°ë¥¼ ë°›ì„ ì¤€ë¹„ê°€ ë ë•Œê¹Œì§€ ë©ˆì¶”ê³  ê¸°ë‹¤ë¦¼.
ê·¸ë‹¤ìŒ ì†¡ì‹ ì´ ì™„ë£Œë¨.
- ê³ ë£¨í‹´ê°„ ë™ê¸°í™” ë³´ì¥í•´ì„œ ì•ˆì „í•˜ê²Œ ë°ì´í„° ì „ë‹¬

v := <- ch 
ì±„ë„ì—ì„œ ë°ì´í„°ë¥¼ ë°›ê¸°.
ì±„ë„ì— ë°ì´í„°ê°€ ì¤€ë¹„ë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼


## ğŸ”¥ğŸ”¥ğŸ”¥ ë°ë“œë½
ì±„ë„ì€ ì¼ì¢…ì˜ íì„.
ì±„ë„ì—ëŠ” ë”± í•˜ë‚˜ë§Œ ë“¤ì–´ê°€ì„œ 3ê°œë¥¼ forë¬¸ìœ¼ë¡œ ì±„ë„ì— ë„£ìœ¼ë ¤í•˜ë©´ ë½ê±¸ë¦¼.
ë³´ë‚´ëŠ” ìª½ì—ì„œ ë½ ê±¸ë ¤ì„œ ë©”ì¸ì—ì„œ ëª»ë°›ê²Œ ë˜ê³ . 
goë£¨í‹´ìœ¼ë¡œ í•˜ë©´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ë˜ë¯€ë¡œ
í•¨ìˆ˜ë‚´ forë¬¸ì—ì„œ ì²«ë²ˆì§¸ê°€ ë“¤ì–´ê°€ë©´ mainìª½ì—ì„œ ë°”ë¡œ ë°›ì„ ìˆ˜ ìˆì–´ì„œ ì•ˆë§‰í˜
-> go í•¨ìˆ˜ê°€ asyncí•˜ê²Œ ë°”ë€ŒëŠ” ê²ƒ. (asyncëŠ” ë¹„ë™ê¸°í•¨ìˆ˜, await ê±¸ì—ˆì„ ë•Œ ìˆœì°¨ì‹¤í–‰ë˜ëŠ”)

ìˆœì°¨ì‹¤í–‰ì´ë¼ í•´ë„ array ë²„í¼ë¡œ ê°œìˆ˜ë¥¼ ëŠ˜ë ¤ì£¼ë©´ ê°€ëŠ¥í•¨.
isOldChan := make(chan bool, 3)

```go
func checkEmailAge(emails [3]email) [3]bool {
	isOldChan := make(chan bool, 3)

    go sendIsOld(isOldChan, emails)

	isOld := [3]bool{}

	fmt.Println("0 work wait")
	isOld[0] = <-isOldChan
	fmt.Println("0 work finish")

	fmt.Println("1 work wait")
	isOld[1] = <-isOldChan
	fmt.Println("1 work finish")

	fmt.Println("2 work wait")
	isOld[2] = <-isOldChan
	fmt.Println("2 work finish")

	return isOld
}

func sendIsOld(isOldChan chan<- bool, emails [3]email) {
	for i, e := range emails {
		fmt.Printf("%d pushed\n", i)
		if e.date.Before(time.Date(2020, 0, 0, 0, 0, 0, 0, time.UTC)) {
			isOldChan <- true
			continue
		}
		isOldChan <- false
	}
}
```
goë£¨í‹´ ì•„ë‹ë•Œ(ìˆœì°¨): 
ë²„í¼ ì—†ìœ¼ë©´ ë°ë“œë½, ë²„í¼ ìˆìœ¼ë©´ sendIsOldê°€ ë¨¼ì € ì™„ì „íˆ ì‹¤í–‰ëœ í›„ checkEmailAgeì˜ ë‚˜ë¨¸ì§€ê°€ ì‹¤í–‰ë¨.
0 pushed
1 pushed
2 pushed
0 work wait
0 work finish
1 work wait
1 work finish
2 work wait
2 work finish

goë£¨í‹´ìœ¼ë¡œ ì‹¤í–‰ì‹œ:
sendIsOldì™€ checkEmailAgeê°€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ë™ì‹œì— ì‹¤í–‰. 
ë²„í¼ ì—†ëŠ” ê²½ìš° 
0 pushed
0 work wait
0 work finish
1 pushed    // ì²« ë²ˆì§¸ ê°’ì´ ì½íŒ í›„ì—ì•¼ ë‹¤ìŒ ê°’ì„ ë³´ë‚¼ ìˆ˜ ìˆìŒ
1 work wait
1 work finish
2 pushed
...

ë‹¨í•­ê°’(unary value) ê°’ ìì²´ëŠ” ì¤‘ìš”í•˜ì§€ ì•Šê³  ì‹ í˜¸ë¡œë§Œ ì‚¬ìš©
// ì‹ í˜¸ ë³´ë‚´ê¸°
ch <- struct{}{}
// ì‹ í˜¸ ë°›ê¸°
<-ch
ì±„ë„ì— ë¬´ì–¸ê°€ ë³´ë‚´ì§ˆ ë•Œê¹Œì§€ ë¸”ë¡ì‹œí‚¬ ìˆ˜ ìˆìŒ.

//
JSì˜ return new Promiseë¥¼ 
Goì—ì„  channelë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŒ.
func getDBChannels() {
    ch := make(chan struct{})
    ch <- struct{}{}
    return ch
}
func main() {
    dbChan = getDBChannels()
    // ğŸ”´dbChanì˜ ëª¨ë“  í† í°ì„ ë°›ì„ ë•Œê¹Œì§€ ì‹¤í–‰ì„ ë©ˆì¶”ê³  ê¸°ë‹¤ë¦¼.
    <-dbChan
}

* Buffered Channels
```go
func addEmailsToQueue(emails []string) chan string {
	ch := make(chan string, len(emails))

	for _, email := range emails {
		ch <- email
	}
	return ch
}

emails := []string{"email1@test.com", "email2@test.com"}
ch := addEmailsToQueue(emails)
// ë‚˜ì¤‘ì— ë‹¤ë¥¸ ê³ ë£¨í‹´ì—ì„œ
for email := range ch {
    // ì´ë©”ì¼ ì²˜ë¦¬
}
```

* Close channel
closed channelì— ë³´ë‚´ë©´ panic ë°œìƒí•˜ê³  main crash ì˜¨ë‹¤.
closing í•˜ì§€ ì•Šìœ¼ë©´ ì•Œì•„ì„œ ê°€ë¹„ì§€ ì½œë ‰íŠ¸ë˜ì–´ì„œ ê´œì°®ë‹¤.
v, ok := <- ch 
ok falseë©´ ë‹«íŒ ê²ƒ.


(í…”ë ˆë©”íŠ¸ë¦¬ Case)
sendReports()ëŠ” reportsë¥¼ ë°°ì¹˜ë¡œ (ì±„ë„ì—) ë³´ë‚´ê³ 
ì±„ë„ì— ëª‡ê°œì˜ reportsê°€ ì „ì†¡ë˜ì—ˆëŠ”ì§€ ë°›ì„ ìˆ˜ ìˆë‹¤. 

numSentCh := make(chan int)ëŠ” int íƒ€ì…ì˜ ë°ì´í„°ë¥¼ ì „ì†¡í•˜ëŠ” ì±„ë„ì„ ìƒì„±
`numSentCh`ëŠ” `sendReports` í•¨ìˆ˜ì™€ `countReports` í•¨ìˆ˜ ì‚¬ì´ì—ì„œ ë°ì´í„°ë¥¼ ì£¼ê³ ë°›ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. 
`sendReports` í•¨ìˆ˜ëŠ” ê° ë°°ì¹˜ë§ˆë‹¤ ë³´ë‚¸ reportì˜ ê°œìˆ˜ë¥¼ `numSentCh` ì±„ë„ì— ë³´ë‚´ê³ ,
`countReports` í•¨ìˆ˜ëŠ” `numSentCh` ì±„ë„ì—ì„œ ê°’ì„ ì½ì–´ì™€ ì´ report ê°œìˆ˜ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

```go
numSentCh := make(chan int)
go sendReports(test.numBatches, numSentCh) // ì±„ë„ì— ë°ì´í„°ë¥¼ ë³´ë‚¸ë‹¤(ğŸ”´async. ì•„ë˜ í•¨ìˆ˜ê°€ ë°”ë¡œ ì‹¤í–‰ë¨. ìˆœì°¨ X)
output := countReports(numSentCh) // ì±„ë„ì—ì„œ ë°ì´í„°ë¥¼ ë°›ì•„ì˜¨ë‹¤
// goë£¨í‹´ -> ê²½ëŸ‰ ìŠ¤ë ˆë“œë¥¼ spawní•´ì„œ ë‘ í•¨ìˆ˜ê°€ ë™ì‹œì— ì‹¤í–‰ë¨. 

func sendReports(numBatches int, ch chan int) {
	for i := 0; i < numBatches; i++ {
		numReports := i*23 + 32%17
		ch <- numReports
	}
	close(ch)
}

func countReports(numSentCh chan int) int {
	total := 0
	for {
		numReports, ok := <- numSentCh
		if !ok {
			break  // ğŸ”´channelì´ close ë˜ì—ˆì„ ë•Œ ë¬´í•œë£¨í”„ ì¢…ë£Œ
		}
		total += numReports
	}
	return total
}
```

* Range
ë™ì‹œì— í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•´ì„œ ê°’ì´ ë‚˜ì˜¤ëŠ”ëŒ€ë¡œ ë°›ì•„ì„œ ë°°ì—´ì— ë„£ëŠ” ì¼€ì´ìŠ¤
- ì±„ë„ì´ ë²„í¼ë§ë˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ,  fibonacci í•¨ìˆ˜ê°€ ch <- xë¥¼ ì‹¤í–‰í•˜ë©´ concurrentFib í•¨ìˆ˜ì˜ num := <-chê°€ ì‹¤í–‰ë  ë•Œê¹Œì§€ ë¸”ë¡ë¨(ê¸°ë‹¤ë¦¼)ğŸ”´. 
- concurrentFibê°€ ê°’ì„ ë°›ìœ¼ë©´ fibonacciê°€ ë‹¤ìŒ ê°’ì„ ê³„ì‚°í•˜ê³  ë³´ë‚¼ ìˆ˜ ìˆëŠ” ìƒíƒœê°€ ë¨.
ì´ëŸ°ì‹ìœ¼ë¡œ ë‘ ê³ ë£¨í‹´ì€ ë™ê¸°í™”ë˜ë©° ê°’ì„ ì£¼ê³ ë°›ìŒ.
- for num := range ch ë£¨í”„ëŠ” ì±„ë„ì´ ë‹«íˆë©´ ìë™ìœ¼ë¡œ ì¢…ë£Œ
```go
func concurrentFib(n int) []int {
	ch := make(chan int)
	arr := make([]int, 0, n)
	go fibonacci(n, ch) 
	for num := range ch {  // ğŸ”´ì˜¤ëŠ”ëŒ€ë¡œ ë°›ëŠ”ë‹¤
		arr = append(arr, num) 
	}
	return arr
}

func fibonacci(n int, ch chan int) {
	x, y := 0, 1
	for i := 0; i < n; i++ {
		ch <- x  // ğŸ”´ch ì±„ë„ì— ê°’ì„ ë³´ë‚¼ ë•Œë§ˆë‹¤ concurrentFib í•¨ìˆ˜ì˜ ë£¨í”„ê°€ ë°”ë¡œ ì‹¤í–‰ë˜ì–´ ê°’ì„ ë°›ê³  arr ë°°ì—´ì— ì¶”ê°€
		x, y = y, x+y
	}
	close(ch)
}
```

---